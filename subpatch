#!/usr/bin/env python3
# SPDX-License-Identifier: GPL-2.0-or-later
# SPDX-FileCopyrightText: Copyright (C) 2024 Stefan Lengfeld

import os
import sys
import shutil
import time
from enum import Enum
from argparse import ArgumentParser
from subprocess import Popen, PIPE, DEVNULL
from os.path import join, abspath
import contextlib

# See https://peps.python.org/pep-0440/ for details about the version format.
# e.g. dashes "-" are not allowed and 'a' stands for 'alpha' release.
__version__ = "0.1a2"

# It's the SPDX identifier. See https://spdx.org/licenses/GPL-2.0-or-later.html
__LICENSE__ = "GPL-2.0-or-later"


# Name conventions for variables
#    path_superproject
#    path_config
#

# TODO refactor. copyied from helpers
@contextlib.contextmanager
def cwd(cwd):
    old_cwd = os.getcwd()
    try:
        os.chdir(cwd)
        yield
    finally:
        os.chdir(old_cwd)


# TODO Write blockpost about common error categories, e.g. in HTTP and errnor
# E.g. there is also
#  * invalid argument
#  * (generic) runtime error (maybe the same as IO error=)
#  * permission deinied
class ErrorCode(Enum):
    UNKNOWN = 1
    NOT_IMPLEMENTED = 2
    NOT_IN_A_GIT_REPO = 3
    # Subpatch is not yet configured for superproject
    NOT_CONFIGURED_FOR_SUPERPROJECT = 4
    # The user has given a invalid argument on the commandline
    INVALID_ARGUMENT = 5
    CUSTOM = 6


class AppException(Exception):
    def __init__(self, code, msg=None):
        self._code = code
        if msg is not None:
            super().__init__(msg)
        else:
            super().__init__()


class URLTypes(Enum):
    LOCAL_RELATIVE = 1
    LOCAL_ABSOLUTE = 2
    REMOTE = 3


def get_url_type(repository_url):
    if len(repository_url) == 0:
        raise ValueError("The repository URL is empty!")
    # TODO mabye using url parsing library?
    # TODO Implemente "file://" prefix
    if repository_url.startswith("http"):
        return URLTypes.REMOTE
    elif repository_url.startswith("git"):
        return URLTypes.REMOTE
    elif repository_url.startswith("ssh"):
        return URLTypes.REMOTE
    if "://" in repository_url:
        raise NotImplementedError("The repository URL '%s' is not implemented yet"
                                  % (repository_url,))
    # Is mostly just a local path
    if repository_url[0] == "/":
        return URLTypes.LOCAL_ABSOLUTE
    return URLTypes.LOCAL_RELATIVE


def nocommand(args, parser):
    parser.print_help(file=sys.stderr)
    return 2  # TODO why 2?


# :: void -> None or byte object (or raises an exception)
def git_get_toplevel():
    p = Popen(["git", "rev-parse", "--show-toplevel"], stdout=PIPE, stderr=DEVNULL)
    stdout, _ = p.communicate()
    if p.returncode == 0:
        return stdout.rstrip(b"\n")
    elif p.returncode == 128:
        # fatal: not a git repository (or any of the parent directories): .git
        return None
    else:
        # TODO Create a generic git error exception
        raise Exception("git failure")


# NOTE This is cwd aware
# TODO add --depth to speed up performance!
# NOTE: Names 'repository_url' and 'directory' are from the 'git clone' docu.
def git_clone(repository_url, directory):
    p = Popen(["git", "clone", "-q", repository_url, directory])
    p.communicate()
    if p.returncode != 0:
        raise Exception("git failure")


def git_add(args):
    assert len(args) >= 1
    p = Popen(["git", "add"] + args)
    p.communicate()
    if p.returncode != 0:
        raise Exception("git failure")

# TODO clarify naming: path, filename, url
# TODO clairfy name for remote git name and path/url

# Namings:
# Git namings
#  - object: something in the object store that has a SHA1
#  - object type: blob, tree, commit, tag
#  - ref: short for "reference", like branches and tags
#  - rev: short for "revision", which are commit objects
# Variable names:
#  - repository_url: The URL for a git/svn/.. repository.
#      Can be a http, git or file URL. Or just a local path.


# Returns the type of the git object as a bytes object without a trailing
# newline.
# TODO Maybe introduce a enum for that
# TODO not use. Implement sanity check
def git_get_object_type(rev):
    p = Popen(["git", "cat-file", "-t", rev], stdout=PIPE, stderr=DEVNULL)
    stdout, _ = p.communicate()
    if p.returncode != 0:
        # TODO Create a generic git error exception
        raise Exception("failed here")

    stdout = stdout.rstrip(b"\n")
    assert stdout in (b"blob", b"commit", b"tree", b"tag")
    return stdout


# Convert URLs. Examples:
#     …bla/foo/.git/ -> "foo"
#     …bla/foo.git/  -> "foo"
#     …bla/foo       -> "foo"
def get_name_from_repository_url(repository_url):
    if len(repository_url) == 0:
        raise ValueError("The repository URL is empty!")
    u = repository_url
    u = u.rstrip("/")
    if u.endswith(".git"):
        u = u[:-4]
    u = u.rstrip("/")
    u = u.split("/")[-1]
    return u


def cmd_add(args, parser):
    if args.url is None:
        # TODO make error message nicer
        raise Exception("Not the correct amount of args")
    if args.path is not None:
        # The optional path argument was given. Make some checks
        if len(args.path) == 0:
            raise AppException(ErrorCode.INVALID_ARGUMENT, "path is empty")
        # TODO But something like "/./././" is also invalid"

    repository_url = args.url

    # TODO check with ls-remote that remote is accessable

    if args.path is None:
        remote_git_name = get_name_from_repository_url(repository_url)
    else:
        remote_git_name = args.path
        # TODO split into path and name component
        # sanitzie path. Remove double slashes trailing slash
        # and paths that are outside of the repository
        # - For now just remove trailing slashes
        remote_git_name = remote_git_name.rstrip("/")

    path_superproject = git_get_toplevel()
    if path_superproject is None:
        raise AppException(ErrorCode.NOT_IN_A_GIT_REPO)

    if get_url_type(repository_url) == URLTypes.LOCAL_RELATIVE:
        # Check the currenty work diretory of the call is the top level
        # directory of the repository. If not, a relative path on the
        # commadline is not relative to the top level diretory and must be
        # converted. This conversion is a bit complex and error prone.  So
        # just enfore (like also git does) that the current work diretory
        # is the top level repository in that case.
        # TODO this comparision is guly. Write this nicer!
        if abspath(os.getcwd().encode(sys.getdefaultencoding())) != abspath(path_superproject):
            raise AppException(ErrorCode.CUSTOM,
                               "When using relative repository URLs, you current work diretory must be the toplevel folder of the superproject!")

    # TODO check that git repo has nothing in the index!
    # But some chnages are ok:
    # TODO add tests that adds a subproject after a "git rm -r" to the same folder.
    # So the changes are in the filesystem and in the index, but not committed yet.
    # This should work

    # TODO Check if the subproject already exists in this dir!
    if os.path.exists(remote_git_name):
        # TODO explain what can be done: Either remove the dir or use another name!
        raise AppException(ErrorCode.CUSTOM,
                           "Directory '%s' alreay exists. Cannot add subproject!" % (remote_git_name,))

    # TOOD create/update ".subpatch" file
    path_config = join(path_superproject, b".subpatch")
    if os.path.exists(path_config):
        raise AppException(ErrorCode.NOT_IMPLEMENTED)

    # TODO maybe add pid to avoid race conditions
    # TODO "git submodule init" creates a bare repoistory in ".git/modules"
    # TODO clone only a single branch and mabye use --depth 1
    assert len(remote_git_name) != 0
    local_tmp_name = remote_git_name + "-tmp"
    git_clone(repository_url, local_tmp_name)

    # Remove ".git" folder in this repo
    local_repo_git_dir = join(local_tmp_name, ".git")
    assert os.path.isdir(local_repo_git_dir)
    shutil.rmtree(local_repo_git_dir)

    # Get local path relative to top level dir
    # TODO refactor that very ugly code !!!!
    git_toplevel_path_realpath = os.path.realpath(path_superproject)
    cwd_local_name_realpath = os.path.realpath(join(os.getcwd(), remote_git_name))
    assert cwd_local_name_realpath.startswith(git_toplevel_path_realpath.decode("utf8"))
    path = cwd_local_name_realpath[len(git_toplevel_path_realpath) + 1:]
    with open(path_config, "w") as f:
        f.write('[subpatch "%s"]\n' % (path,))
        # TODO repository_url is the verbatim copy of the argument. It my
        # contain a trailing slash that is not significant. Should the trainling slash be removed?
        # Or the varbatim copy of the argument used?
        # TODO if the path is relative to a local folder, it's relative to the current working directory.
        # Then also the path in the config file is relative.
        # This can be wired, because it then depends on the cwd of the inovcation!
        f.write("\turl = %s\n" % (repository_url,))

    # Move files into place
    os.rename(local_tmp_name, remote_git_name)

    # TODO in case of failure, remove download git dir!

    # Add files for committing
    # TODO git_add must use "-f" otherwise ignore files are used and not all files are added!
    git_add([remote_git_name])
    with cwd(path_superproject):
        git_add([".subpatch"])

    # TODO prepare commit message

    # NOTE: Design decision: The output is relative to the current working dir.
    # The content of '%s' is the remote git name or the path relative to the
    # current working dir. It's not relative to the top level dir of the git repo.
    print("Adding subproject '%s' was successful." % (remote_git_name,))
    print("- To inspect the changes, use `git status` and `git diff --staged`.")
    print("- If you want to keep the changes, commit them with `git commit`.")
    print("- If you want to revert the changes, execute 'git reset --merge`.")

    # TODO Idea "subpatch status" should print the info/help text. The status
    # command should be command to get help if a user is lost.

    return 0


def show_version(args):
    print("subpatch version %s" % (__version__,))
    return 0


def show_info(args):
    print("homepage:  https://subpatch.net")
    print("git repo:  https://github.com/lengfeld/subpatch")
    print("license:   %s" % (__LICENSE__,))
    # TODO add GPL license text/note
    return 0


def cmd_status(args, parser):
    # TODO unify search for superproject with other commands!
    path_superproject = git_get_toplevel()
    if path_superproject is None:
        raise AppException(ErrorCode.NOT_IN_A_GIT_REPO)

    # Find subpatch file
    # Design decision:
    # Having a empty ".subpatch" config file is something different than having
    # no config file. It means that subpach is not yet configured for the project.
    path_config = join(path_superproject, b".subpatch")
    if not os.path.exists(path_config):
        raise AppException(ErrorCode.NOT_CONFIGURED_FOR_SUPERPROJECT)

    # Just dump the contents of the file for now
    # TODO read config format  make nice output
    # TODO add note that it's a pretty printed output for humans. Do
    # not use in scripts.
    # TODO add plumbing commands for scripts!
    print("NOTE: Output format is just a hack. Not the final output format yet!")
    with open(path_config) as f:
        print(f.read(), end="")

    return 0


def main_wrapped():
    # TODO maybe add 'epilog' again
    parser = ArgumentParser(description='Adding subprojects into a git repo, the superproject.')
    parser.add_argument("--version", "-v", dest="version",
                        action="store_true", default=False,
                        help="Show version of program")
    parser.add_argument("--info", dest="info",
                        action="store_true", default=False,
                        help="Show more information, like homepage, repo and license")

    subparsers = parser.add_subparsers()

    parser_add = subparsers.add_parser("add",
                                       help="Fetch and add a subproject")
    parser_add.set_defaults(func=cmd_add)
    parser_add.add_argument(dest="url", type=str,
                            help="URL or path to git repo")
    parser_add.add_argument(dest="path", type=str, default=None, nargs='?',
                            help="folder or path in the local repo")

    parser_status = subparsers.add_parser("status",
                                          help="List all subprojects in the superproject")
    parser_status.set_defaults(func=cmd_status)

    args = parser.parse_args()

    # Just for testing. A bit ugly to have this in the production code.
    if os.environ.get("HANG_FOR_TEST", "0") == "1":
        time.sleep(5)

    if args.version:
        ret = show_version(args)
    elif args.info:
        ret = show_info(args)
    else:
        # Workaround for help
        if hasattr(args, "func"):
            ret = args.func(args, parser)
        else:
            ret = nocommand(args, parser)

    return ret


def main():
    try:
        ret = main_wrapped()
    except AppException as e:
        # TODO allow to append a generic error message for all messages, not only for invalid argument.
        if e._code == ErrorCode.NOT_IMPLEMENTED:
            # TODO error code should have a message to explain the exact feature
            # TODO the message should show the github issue url!
            print("Error: Feature not implemented yet!", file=sys.stderr)
        elif e._code == ErrorCode.NOT_IN_A_GIT_REPO:
            print("Error: No git repo as superproject found!", file=sys.stderr)
        elif e._code == ErrorCode.NOT_CONFIGURED_FOR_SUPERPROJECT:
            # TODO add steps to resolve the issue. e.g. touching the file
            print("Error: subpatch not yet configured for superproject!", file=sys.stderr)
        elif e._code == ErrorCode.INVALID_ARGUMENT:
            # TODO change structure of errors. It contains two colons now.
            # Looks ugly.
            print("Error: Invalid arguments: %s" % (e,), file=sys.stderr)
        elif e._code == ErrorCode.CUSTOM:
            print("Error: %s" % (e,), file=sys.stderr)
        else:
            assert e._code == ErrorCode.UNKNOWN
            # TODO find a better name for UNKNOWN
            # Dont' print a message here. The caller has already written the
            # message.
            # TODO maybe it still better that the error is printed here and not
            # printed by the caller!
            pass
        ret = 4
    except KeyboardInterrupt:
        print("Interrupted!", file=sys.stderr)
        # TODO What is the correct/best error code?
        ret = 3
    sys.exit(ret)


if __name__ == '__main__':
    main()
    raise Exception("Never reached!")
