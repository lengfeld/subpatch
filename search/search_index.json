{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"subpatch: fearless multi repository management - stay relaxed! Welcome to the website of subpatch. The tool that does multi repository management right. Don't worry, stay relaxed! If you are currently using git-submodules or repo and you are frustrated, subpatch will be mostly your solution! If you are interested, email me . Note : subpatch is not production ready. It's currently a prototype. Nevertheless please try it out and give feedback. I will incorperate it. Quick start If you want to try out the subpatch tool really quickly, follow the instructions: # First go into the toplevel directory of your project that is using git, ... $ git status # then download the subpatch python script, ... $ wget https://subpatch.net/downloads/latest/subpatch $ chmod +x ./subpatch # and finally add a subproject to your (super)project! $ ./subpatch add https://github.com/google/googletest external/googletest -r v1.15.2 $ ./subpatch status $ git commit -m \"adding googletest\" $ ./subpatch status If you are interested in finding out more, please see the text below and the menu of this website on the left side. It contains explanations, tutorials, how-to guides and references about subpatch. Usecases subpatch is interesting for you if you want to do the following tasks: assemble a monorepo from multiple repositories integrate third party dependencies into your project as source files (also called 'vendoring') maintain a local fork (with a linear patchstack) of an upstream project Concept and design subpatch is a multi repository management tool based on the following ideas: It's based on git add . The files of subprojects are added as normal files to the superproject. Subprojects are in most cases just other git repositories. The metadata of a subproject is saved in a git-config styled configuration file. Modifications of the subproject are possible and subpatch helps to maintain a linear patch stack of the modifications. Importing new versions of the subproject is possible and subpatch helps to rebase the local modifications. Main differences to other tools When you use subpatch the subprojects are not git repository itself. The files of the subprojects are added as files to the superproject. You will only have to deal with a single git repository. This is in contrast to other tools, e.g. git-submodules repo kas west These tools manage multiple git repositories at once. Based on a manifest file multiple git repositories are cloned from different upstream sources into your local checkout. The page Comparison to other tools describes the differences in more detail. Website, documentation and support On this website you find more information and the documentation, e.g. explanations, tutorials, how-to guides and references. New software releases are announced on the release notes page , including the release notes and changelog. For support, dicussions and feature requests you can join the matrix room #subpatch:matrix.org , open an issue on github or email me . Code, licenses and contributions The source code of the program and the website can be found in the git repository github.com/lengfeld/subpatch . I have licensed the source code of subpatch as GPL-2.0-only , It's the same license that is also used for the Linux kernel or git itself. I licensed the content of the website as Creative Commons Attribution-ShareAlike 4.0 International / CC BY-SA 4.0 . In short this means: you can use the work, must give attribution, can use it commercially, too, and you must release derived work under the same license. When you contribute, please add your sign-off. See Developer's Certificate of Origin for details. It's used in the Linux kernel and other projects. Note : For now the project does not welcome code contributions yet . The code is in a very rough state (in average one TODO comment per 10 lines of code). So don't waste our time trying to implement features. I want to get the internal architecture right first. Nevertheless, feedback and comments to the tool and concepts is very welcome. Warranty disclaimer The standard license header and warranty disclaimer of the GPLv2 is: Copyright (C) 2024 Stefan Lengfeld This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; as version 2 of the License. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.","title":"Home"},{"location":"#subpatch-fearless-multi-repository-management-stay-relaxed","text":"Welcome to the website of subpatch. The tool that does multi repository management right. Don't worry, stay relaxed! If you are currently using git-submodules or repo and you are frustrated, subpatch will be mostly your solution! If you are interested, email me . Note : subpatch is not production ready. It's currently a prototype. Nevertheless please try it out and give feedback. I will incorperate it.","title":"subpatch: fearless multi repository management - stay relaxed!"},{"location":"#quick-start","text":"If you want to try out the subpatch tool really quickly, follow the instructions: # First go into the toplevel directory of your project that is using git, ... $ git status # then download the subpatch python script, ... $ wget https://subpatch.net/downloads/latest/subpatch $ chmod +x ./subpatch # and finally add a subproject to your (super)project! $ ./subpatch add https://github.com/google/googletest external/googletest -r v1.15.2 $ ./subpatch status $ git commit -m \"adding googletest\" $ ./subpatch status If you are interested in finding out more, please see the text below and the menu of this website on the left side. It contains explanations, tutorials, how-to guides and references about subpatch.","title":"Quick start"},{"location":"#usecases","text":"subpatch is interesting for you if you want to do the following tasks: assemble a monorepo from multiple repositories integrate third party dependencies into your project as source files (also called 'vendoring') maintain a local fork (with a linear patchstack) of an upstream project","title":"Usecases"},{"location":"#concept-and-design","text":"subpatch is a multi repository management tool based on the following ideas: It's based on git add . The files of subprojects are added as normal files to the superproject. Subprojects are in most cases just other git repositories. The metadata of a subproject is saved in a git-config styled configuration file. Modifications of the subproject are possible and subpatch helps to maintain a linear patch stack of the modifications. Importing new versions of the subproject is possible and subpatch helps to rebase the local modifications.","title":"Concept and design"},{"location":"#main-differences-to-other-tools","text":"When you use subpatch the subprojects are not git repository itself. The files of the subprojects are added as files to the superproject. You will only have to deal with a single git repository. This is in contrast to other tools, e.g. git-submodules repo kas west These tools manage multiple git repositories at once. Based on a manifest file multiple git repositories are cloned from different upstream sources into your local checkout. The page Comparison to other tools describes the differences in more detail.","title":"Main differences to other tools"},{"location":"#website-documentation-and-support","text":"On this website you find more information and the documentation, e.g. explanations, tutorials, how-to guides and references. New software releases are announced on the release notes page , including the release notes and changelog. For support, dicussions and feature requests you can join the matrix room #subpatch:matrix.org , open an issue on github or email me .","title":"Website, documentation and support"},{"location":"#code-licenses-and-contributions","text":"The source code of the program and the website can be found in the git repository github.com/lengfeld/subpatch . I have licensed the source code of subpatch as GPL-2.0-only , It's the same license that is also used for the Linux kernel or git itself. I licensed the content of the website as Creative Commons Attribution-ShareAlike 4.0 International / CC BY-SA 4.0 . In short this means: you can use the work, must give attribution, can use it commercially, too, and you must release derived work under the same license. When you contribute, please add your sign-off. See Developer's Certificate of Origin for details. It's used in the Linux kernel and other projects. Note : For now the project does not welcome code contributions yet . The code is in a very rough state (in average one TODO comment per 10 lines of code). So don't waste our time trying to implement features. I want to get the internal architecture right first. Nevertheless, feedback and comments to the tool and concepts is very welcome.","title":"Code, licenses and contributions"},{"location":"#warranty-disclaimer","text":"The standard license header and warranty disclaimer of the GPLv2 is: Copyright (C) 2024 Stefan Lengfeld This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; as version 2 of the License. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.","title":"Warranty disclaimer"},{"location":"imprint/","text":"Imprint This website is created and maintained by name: Stefan Lengfeld address: Germany, 53721 Siegburg e-mail: stefan+subpatch@lengfeld.xyz The website's source is available in the folder website/ in the subpatch repository . This website is using posthog.com for analytics.","title":"Imprint"},{"location":"imprint/#imprint","text":"This website is created and maintained by name: Stefan Lengfeld address: Germany, 53721 Siegburg e-mail: stefan+subpatch@lengfeld.xyz The website's source is available in the folder website/ in the subpatch repository . This website is using posthog.com for analytics.","title":"Imprint"},{"location":"exp/benefits/","text":"Benefits This page lists all the benefits you Right tradeoffs for users tdb To explain that maintainer use it, not contributors! No pitfalls like in repo or git-submodules easy branch swichting no git-submodules headeaches no way to forget to init a submodule Source code reproductabilty by design (=mirroring,=vendoring) Since of DDX, the files of the subprojects are added directly to your source control management system (=git). This means that you don't rely on the availablity of servers or services of the upstream project. If a upstream project shutsdown it download servers for the tarballs or removes their repository on github, you still have all the source code for building all of our software release. It's mirror by default in your scms. For (license) compliance and security bug fixing it's a requirement to be able to reproduce the source code and rebuild all or at least some of the latests software releases. If you use git submodules, repo or other tools and you don't want to depend on upstream, you have to implement our own mirror and infrastructure. With subpatch you get it for free. Better caching and reduced ingress traffic no additional downloading in CI Built-in patching For repo, git-submodules this needs forking/mirroro subpatch has this built-in an easy to use without hassel of extra repos. Better visiblity in size of upgrades of dependencies currently you don't see it in the diff-size The right tradeoffs no direct history, but documented Conclusion see FAQ Drawbags increased storage size of git forge/git server Monorepo problems For very big projects, git does not scale well. But has improved","title":"Benefits"},{"location":"exp/benefits/#benefits","text":"This page lists all the benefits you","title":"Benefits"},{"location":"exp/benefits/#right-tradeoffs-for-users","text":"tdb To explain that maintainer use it, not contributors! No pitfalls like in repo or git-submodules easy branch swichting no git-submodules headeaches no way to forget to init a submodule","title":"Right tradeoffs for users"},{"location":"exp/benefits/#source-code-reproductabilty-by-design-mirroringvendoring","text":"Since of DDX, the files of the subprojects are added directly to your source control management system (=git). This means that you don't rely on the availablity of servers or services of the upstream project. If a upstream project shutsdown it download servers for the tarballs or removes their repository on github, you still have all the source code for building all of our software release. It's mirror by default in your scms. For (license) compliance and security bug fixing it's a requirement to be able to reproduce the source code and rebuild all or at least some of the latests software releases. If you use git submodules, repo or other tools and you don't want to depend on upstream, you have to implement our own mirror and infrastructure. With subpatch you get it for free.","title":"Source code reproductabilty by design (=mirroring,=vendoring)"},{"location":"exp/benefits/#better-caching-and-reduced-ingress-traffic","text":"no additional downloading in CI","title":"Better caching and reduced ingress traffic"},{"location":"exp/benefits/#built-in-patching","text":"For repo, git-submodules this needs forking/mirroro subpatch has this built-in an easy to use without hassel of extra repos.","title":"Built-in patching"},{"location":"exp/benefits/#better-visiblity-in-size-of-upgrades-of-dependencies","text":"currently you don't see it in the diff-size","title":"Better visiblity in size of upgrades of dependencies"},{"location":"exp/benefits/#the-right-tradeoffs","text":"no direct history, but documented","title":"The right tradeoffs"},{"location":"exp/benefits/#conclusion","text":"see FAQ","title":"Conclusion"},{"location":"exp/benefits/#drawbags","text":"","title":"Drawbags"},{"location":"exp/benefits/#increased-storage-size-of-git-forgegit-server","text":"","title":"increased storage size of git forge/git server"},{"location":"exp/benefits/#monorepo-problems","text":"For very big projects, git does not scale well. But has improved","title":"Monorepo problems"},{"location":"exp/benefits/#_1","text":"","title":""},{"location":"exp/comparison/","text":"Comparison to other tools subpatch is not the first tool that tries to solve the multi repository problem. Other tools are git-submodules repo kas west git-subtree This page will compare these tools with subpatch. Technical comparison The following table compares the architecture of the tools subpatch repo git submodule west kas subtree config format git-cfg xml git-cfg yaml yaml none superproject any(1) none git git git git subprojects any(1) git git git git git language python python C python python shell agnostic yes yes yes no no yes Explanations of the rows: config format : The format of the config file that is used to track the information about the subprojects. For repo and west the file is called the manifest file. superproject : The type of cvs that is the top level repository and also (often) tracks the configuration of subprojects. (2) subprojects : The type of cvs that is support as a subproject. For all other tools, except subpatch, only other git repositories are supported. language : The main programming language that the tool is written in. agnostic : Whether the tool is project/tooling agnostic or tailored to a specific project or usecase. E.g. kas is designed for the Yocto project and west is designed for Zephyr. Legend: git-cfg stands for the git config format used in .git/config , ~/.gitconfig and .gitmodules . (1): subpatch does not support all other cvs as super- and subprojects for now. Still work in progress. (2): The repo tool is special here. It tracks the subprojects in a manifest file in a separate git repository, the so called manifest repository . But this repository is not part of the directory hierarchy when the project is checked out. It does not sit at the top level of the superproject. Even more multi repository management tools Apart from the above already mentioned tools there exits a long list of other attempts to solve the multi repository problem. The following list should list all the other tools I have found so far: Git X-Modules GitSlave Combo-layer Josh git-toprepo dfetch git-vendor If you know additional tools, please post a pull request or email me. If you want to see a even longer list of other tools, checkout out the alternatives page from dfetch .","title":"Comparison to other tools"},{"location":"exp/comparison/#comparison-to-other-tools","text":"subpatch is not the first tool that tries to solve the multi repository problem. Other tools are git-submodules repo kas west git-subtree This page will compare these tools with subpatch.","title":"Comparison to other tools"},{"location":"exp/comparison/#technical-comparison","text":"The following table compares the architecture of the tools subpatch repo git submodule west kas subtree config format git-cfg xml git-cfg yaml yaml none superproject any(1) none git git git git subprojects any(1) git git git git git language python python C python python shell agnostic yes yes yes no no yes Explanations of the rows: config format : The format of the config file that is used to track the information about the subprojects. For repo and west the file is called the manifest file. superproject : The type of cvs that is the top level repository and also (often) tracks the configuration of subprojects. (2) subprojects : The type of cvs that is support as a subproject. For all other tools, except subpatch, only other git repositories are supported. language : The main programming language that the tool is written in. agnostic : Whether the tool is project/tooling agnostic or tailored to a specific project or usecase. E.g. kas is designed for the Yocto project and west is designed for Zephyr. Legend: git-cfg stands for the git config format used in .git/config , ~/.gitconfig and .gitmodules . (1): subpatch does not support all other cvs as super- and subprojects for now. Still work in progress. (2): The repo tool is special here. It tracks the subprojects in a manifest file in a separate git repository, the so called manifest repository . But this repository is not part of the directory hierarchy when the project is checked out. It does not sit at the top level of the superproject.","title":"Technical comparison"},{"location":"exp/comparison/#even-more-multi-repository-management-tools","text":"Apart from the above already mentioned tools there exits a long list of other attempts to solve the multi repository problem. The following list should list all the other tools I have found so far: Git X-Modules GitSlave Combo-layer Josh git-toprepo dfetch git-vendor If you know additional tools, please post a pull request or email me. If you want to see a even longer list of other tools, checkout out the alternatives page from dfetch .","title":"Even more multi repository management tools"},{"location":"exp/design/","text":"Design decisions While developing subpatch, I took the following design decisions. The requirement list still gives a lot of freedom for the implementation. Therefore this page documents and explains the chosen decisions here. DD1 : written in python3 (but open for a port to another language later if successful) [+] faster iteration speed [+] Easier deployment/install for users of subpatch. python runs everywhere. [+] Programming language that I know really good and written a lot of code already. DD2 : config file format is git-config [+] the same config format that the main scm tool for subpatch (=git) uses. [+] Most developers are already familiar with the config format, e.g. because they are modyfing ~/.git config . DD3 : The config is a single file and placed at the root of the repository [+] The project's root directory can be found even without scm. E.g. after the source code was exported with git archive . [+] A single file avoids a search in all sub directories. Can be expensive for big projects. TODO: Update this DD. subpatch has .subproject files now that are seperate from the subpatch config file. DD4 : Published as a standalone and single python script TODO add [+] points here DD5 : Filenames and file system paths are python bytes objects, not strings TODO add [+] points here DD6 : The subproject's history is not include in the superproject's history. TODO E.g. git-subtree and combo-layers are doing this TODO Including the history is against learing L4 (minimize accidentally complexity) TODO add [+],[-] points here DD7 : The naming convention in config and metadata is the git config style. In the config file .subpatch and metadata files .subproject (that are git config files) the naming convention is camelCase . See these example from the git documentation. [+] Consistency, since supatch is using the same style as git itself. Note : This list is not completed yet and should grow while supbatch is developed.","title":"Design decisions"},{"location":"exp/design/#design-decisions","text":"While developing subpatch, I took the following design decisions. The requirement list still gives a lot of freedom for the implementation. Therefore this page documents and explains the chosen decisions here. DD1 : written in python3 (but open for a port to another language later if successful) [+] faster iteration speed [+] Easier deployment/install for users of subpatch. python runs everywhere. [+] Programming language that I know really good and written a lot of code already. DD2 : config file format is git-config [+] the same config format that the main scm tool for subpatch (=git) uses. [+] Most developers are already familiar with the config format, e.g. because they are modyfing ~/.git config . DD3 : The config is a single file and placed at the root of the repository [+] The project's root directory can be found even without scm. E.g. after the source code was exported with git archive . [+] A single file avoids a search in all sub directories. Can be expensive for big projects. TODO: Update this DD. subpatch has .subproject files now that are seperate from the subpatch config file. DD4 : Published as a standalone and single python script TODO add [+] points here DD5 : Filenames and file system paths are python bytes objects, not strings TODO add [+] points here DD6 : The subproject's history is not include in the superproject's history. TODO E.g. git-subtree and combo-layers are doing this TODO Including the history is against learing L4 (minimize accidentally complexity) TODO add [+],[-] points here DD7 : The naming convention in config and metadata is the git config style. In the config file .subpatch and metadata files .subproject (that are git config files) the naming convention is camelCase . See these example from the git documentation. [+] Consistency, since supatch is using the same style as git itself. Note : This list is not completed yet and should grow while supbatch is developed.","title":"Design decisions"},{"location":"exp/faq/","text":"Frequently asked questions What does the name subpatch mean? The name subpatch consists of two parts: sub and patch The term sub is inspired by git submodules and git subtree . Both use the prefix sub , because the act on sub directories. subpatch does the same. Third party dependencies (=subprojects) are added as subdirectories to the superproject. The second term patch stands for patching the source code. subpatch allows to maintain a linear patch stack on top of the subproject. As far as I know, this is a unique feature for multi repository management tools like subpatch. Subpatch is just another wrapper around git, right? No, subpatch is not another wrapper around git. Like git submodules or git subtree, subpatch is an extension to git. Refere to the learning (L1) on Learnings : The solution to the multi repository problem is inside of git (or generally inside any version control system). E.g., look at two common operations for SCM tools: tagging and switches branches. For subpatch git switch and git tag just work as before. When tagging a release, all source code files and all subprojects are tagged with a single command and a single tag. Same for git switch . With the same command, all source code files and all subprojects are switched to a different branch. Now look at the repo tool, which I call a wrapper around git. How does tagging work? There is no single command to tag the whole superproject. You have to perform multiple steps $ repo forall git tag -a ... # tag all subprojects individually $ repo forall git push <remote name> <tagname> # Now continue in the manifest repository $ cd ../manifest-repo $ vim manifest.xml # replace default revision with newly create tag $ git commit -a -m \"add tag in release manifest\" $ git push origin HEAD:refs/heads/release-xy So just making a release, consists of multiple steps. And the whole process is error prone and not atomic. If you make a error somewhere, there is no easy way to roll back everything. It's the same issue apply when switching branches. The repo tool does not support an easy way to checkout the branches of pull request/merged. For that some of my coworkers and I coded our own tool. See repoload . That's why I call repo and other tools \"a wrapper around git\", because existing features of a SCM tool are reimplemented or need to be reimplemented. And subpatch is carefully designed to not be a wrapper around git.","title":"Frequently asked questions"},{"location":"exp/faq/#frequently-asked-questions","text":"","title":"Frequently asked questions"},{"location":"exp/faq/#what-does-the-name-subpatch-mean","text":"The name subpatch consists of two parts: sub and patch The term sub is inspired by git submodules and git subtree . Both use the prefix sub , because the act on sub directories. subpatch does the same. Third party dependencies (=subprojects) are added as subdirectories to the superproject. The second term patch stands for patching the source code. subpatch allows to maintain a linear patch stack on top of the subproject. As far as I know, this is a unique feature for multi repository management tools like subpatch.","title":"What does the name subpatch mean?"},{"location":"exp/faq/#subpatch-is-just-another-wrapper-around-git-right","text":"No, subpatch is not another wrapper around git. Like git submodules or git subtree, subpatch is an extension to git. Refere to the learning (L1) on Learnings : The solution to the multi repository problem is inside of git (or generally inside any version control system). E.g., look at two common operations for SCM tools: tagging and switches branches. For subpatch git switch and git tag just work as before. When tagging a release, all source code files and all subprojects are tagged with a single command and a single tag. Same for git switch . With the same command, all source code files and all subprojects are switched to a different branch. Now look at the repo tool, which I call a wrapper around git. How does tagging work? There is no single command to tag the whole superproject. You have to perform multiple steps $ repo forall git tag -a ... # tag all subprojects individually $ repo forall git push <remote name> <tagname> # Now continue in the manifest repository $ cd ../manifest-repo $ vim manifest.xml # replace default revision with newly create tag $ git commit -a -m \"add tag in release manifest\" $ git push origin HEAD:refs/heads/release-xy So just making a release, consists of multiple steps. And the whole process is error prone and not atomic. If you make a error somewhere, there is no easy way to roll back everything. It's the same issue apply when switching branches. The repo tool does not support an easy way to checkout the branches of pull request/merged. For that some of my coworkers and I coded our own tool. See repoload . That's why I call repo and other tools \"a wrapper around git\", because existing features of a SCM tool are reimplemented or need to be reimplemented. And subpatch is carefully designed to not be a wrapper around git.","title":"Subpatch is just another wrapper around git, right?"},{"location":"exp/intro/","text":"Introduction Welcome to the realm of multi repository management and third-party source dependencies. Even if you are an experienced software developer, you may not have encountered this issue in your career already. It only arises when working on larger software projects, managing inter-team software dependencies, or in the field of embedded software engineering. This page explains the issue with two examples: Example 1: C/C++ library as source dependency Example 2: multi repository project for linux embedded firmware Example 1: C/C++ library as source dependency This example illustrates a third party source dependency. I maintain a small C/C++ library called aminilog . It's useful when writing C/C++ code in an Android Application project that uses the Android NDK (Native Development toolkit). The library provides ready to use logging macros, because the NDK only contains the low level APIs for logging. I publish the library as a plain git repository. Since it is really simple, there are no release tarballs or tags and no binary artifacts. Also binary artifacts would do not make sense, because all of the library content are C/C++ macros that must be evaluated at compile time. In 2023 I prepared a talk about the Glass-To-Glass-Latency in Android . For my latency experiments I created a git repository and needed the above mentioned C/C++ library as a source dependency. I develop an Android Application that could perform various tests and experiments. The code of the application is on github in the repo inovex/android-glass-to-glass-latency . In this application I also used the Android NDK to write some C++ code to access some libc functions from Java and to trigger the torch light of the Pixel2 phone as fast as possible. And while written and testing the C++ code I needed to write some log messages. Therefore I imported my aminilog library as a source dependency into the project. The commands were roughly the following: $ mkdir external/ $ cd external/ $ git clone https://github.com/lengfeld/aminilog.git $ rm -rf aminilog/.git $ git add aminilog/ $ git commit -m \"add aminilog dependency\" And then I integrated the library into the cmake build systems by adding the line add_subdirectory(../../../../pixeltorch pixeltorch) [...] target_link_libraries(${PROJECT_NAME} android [...] aminilog) into the CMakeLists.txt . That was all. I added the source files of the aminilog library as files to the git repository android-glass-to-glass-latency and integrated them to the cmake build system. In this example the git repository android-glass-to-glass-latency is the superproject and the source dependency aminilog is the subproject. Example 2: Embedded Linux firmware based on Yocto This example illustrates a multi repository setup of a Yocto project. The Yocto project is a build system to build a Linux embedded distribution and firmware. It's based on OpenEmbedded. The core consists of bitbake (recipe parser and build orchestration) meta-oecore (base recipes and toolchain) documentation the poky distro All of this is bundled in the poky repository . Poky is often used as a based for embedded Linux firmware projects, but you can also add the different components separately. Furthermore the Yocto project has the concept of layers. These are git repositories by external parties that contains additional recipes, bbappends, machines and distros. These add additional hardware support, software and other features. E.g. meta-qt adds support for the QT graphics framework and meta-raspperypi adds support for the RaspberryPI hardware. In general building an embedded firmware with Yocto consists of using poky and 2 or more additional external layers. And mostly also maintaining your own layer with build configurations, additional patches and recipes for your own applications. As a developer you would clone multiple repositories . An example: $ git clone https://git.yoctoproject.org/poky $ git clone git://git.openembedded.org/meta-openembedded $ git clone https://git.yoctoproject.org/meta-raspberrypi Then you would configure the build and add the layers. $ . poky/oe-init-build-env $ vim conf/bblayers.conf $ vim conf/local.conf $ bitbake some-image Then adding our own layer for your modifications: $ bitbake-layers create-layer ../meta-mylayer $ cd ../meta-mylayer $ git init # e.g. add an image recipe $ git commit -m \"add image reipce\" And finally you start the build $ bitbake my-image and use the firmware files in the build artifacts to flash your device. This is also an example of a multi repository management problem. To make a firmware build for the device you, a coworker and the continuous integration pipeline needs to clone four different repositories, namely poky, meta-openembedded, meta-raspperypi and meta-mylayer. The first three repos are maintained by external parties. The last repo is maintained by you. Since everyone is facing the multi repository problem when working on Yocto projects, there are already some attempts to handle it. E.g. some use repo or git submodules as generic solutions to the multi repository problem. But there is also the kas project. It allows to checkout multi external git repos and provides a lot additional feature for maintaining Yocto projects. E.g. to assemble the local.conf and bblayers.conf dynamically. Recap The two examples show the multi repository problem. Now you can continue reading my learnings and history of the past years dealing with this problem.","title":"Introduction"},{"location":"exp/intro/#introduction","text":"Welcome to the realm of multi repository management and third-party source dependencies. Even if you are an experienced software developer, you may not have encountered this issue in your career already. It only arises when working on larger software projects, managing inter-team software dependencies, or in the field of embedded software engineering. This page explains the issue with two examples: Example 1: C/C++ library as source dependency Example 2: multi repository project for linux embedded firmware","title":"Introduction"},{"location":"exp/intro/#example-1-cc-library-as-source-dependency","text":"This example illustrates a third party source dependency. I maintain a small C/C++ library called aminilog . It's useful when writing C/C++ code in an Android Application project that uses the Android NDK (Native Development toolkit). The library provides ready to use logging macros, because the NDK only contains the low level APIs for logging. I publish the library as a plain git repository. Since it is really simple, there are no release tarballs or tags and no binary artifacts. Also binary artifacts would do not make sense, because all of the library content are C/C++ macros that must be evaluated at compile time. In 2023 I prepared a talk about the Glass-To-Glass-Latency in Android . For my latency experiments I created a git repository and needed the above mentioned C/C++ library as a source dependency. I develop an Android Application that could perform various tests and experiments. The code of the application is on github in the repo inovex/android-glass-to-glass-latency . In this application I also used the Android NDK to write some C++ code to access some libc functions from Java and to trigger the torch light of the Pixel2 phone as fast as possible. And while written and testing the C++ code I needed to write some log messages. Therefore I imported my aminilog library as a source dependency into the project. The commands were roughly the following: $ mkdir external/ $ cd external/ $ git clone https://github.com/lengfeld/aminilog.git $ rm -rf aminilog/.git $ git add aminilog/ $ git commit -m \"add aminilog dependency\" And then I integrated the library into the cmake build systems by adding the line add_subdirectory(../../../../pixeltorch pixeltorch) [...] target_link_libraries(${PROJECT_NAME} android [...] aminilog) into the CMakeLists.txt . That was all. I added the source files of the aminilog library as files to the git repository android-glass-to-glass-latency and integrated them to the cmake build system. In this example the git repository android-glass-to-glass-latency is the superproject and the source dependency aminilog is the subproject.","title":"Example 1: C/C++ library as source dependency"},{"location":"exp/intro/#example-2-embedded-linux-firmware-based-on-yocto","text":"This example illustrates a multi repository setup of a Yocto project. The Yocto project is a build system to build a Linux embedded distribution and firmware. It's based on OpenEmbedded. The core consists of bitbake (recipe parser and build orchestration) meta-oecore (base recipes and toolchain) documentation the poky distro All of this is bundled in the poky repository . Poky is often used as a based for embedded Linux firmware projects, but you can also add the different components separately. Furthermore the Yocto project has the concept of layers. These are git repositories by external parties that contains additional recipes, bbappends, machines and distros. These add additional hardware support, software and other features. E.g. meta-qt adds support for the QT graphics framework and meta-raspperypi adds support for the RaspberryPI hardware. In general building an embedded firmware with Yocto consists of using poky and 2 or more additional external layers. And mostly also maintaining your own layer with build configurations, additional patches and recipes for your own applications. As a developer you would clone multiple repositories . An example: $ git clone https://git.yoctoproject.org/poky $ git clone git://git.openembedded.org/meta-openembedded $ git clone https://git.yoctoproject.org/meta-raspberrypi Then you would configure the build and add the layers. $ . poky/oe-init-build-env $ vim conf/bblayers.conf $ vim conf/local.conf $ bitbake some-image Then adding our own layer for your modifications: $ bitbake-layers create-layer ../meta-mylayer $ cd ../meta-mylayer $ git init # e.g. add an image recipe $ git commit -m \"add image reipce\" And finally you start the build $ bitbake my-image and use the firmware files in the build artifacts to flash your device. This is also an example of a multi repository management problem. To make a firmware build for the device you, a coworker and the continuous integration pipeline needs to clone four different repositories, namely poky, meta-openembedded, meta-raspperypi and meta-mylayer. The first three repos are maintained by external parties. The last repo is maintained by you. Since everyone is facing the multi repository problem when working on Yocto projects, there are already some attempts to handle it. E.g. some use repo or git submodules as generic solutions to the multi repository problem. But there is also the kas project. It allows to checkout multi external git repos and provides a lot additional feature for maintaining Yocto projects. E.g. to assemble the local.conf and bblayers.conf dynamically.","title":"Example 2: Embedded Linux firmware based on Yocto"},{"location":"exp/intro/#recap","text":"The two examples show the multi repository problem. Now you can continue reading my learnings and history of the past years dealing with this problem.","title":"Recap"},{"location":"exp/learnings/","text":"Learnings On the previous introductions page , you could read about the basics of the multi repository problem. subpatch is not my first attempt to solve the multi repository problem. There is a long history before I started the subpatch project. This page should tell the history and what learnings I made along the way. lt;dr: The summary of all learnings is ( L1 ) The solution to the multi repository problem is inside of git (or generally inside any version control system). ( L2 ) Good documentation is very very important. ( L3 ) Good documentation with good tooling is the key. ( L4 ) Use the right design to minimize the inherent complexity to avoid accidental complexity. ( L5 ) The build process must stay inside of a single repository. ( L6 ) The only sane way to maintain a downstream fork is a linear patch stack (=series of patches). ( L7 ) Good development practices, like atomic commits, must still be possible with the multi repository management tool. Even across the used subprojects. Personal history While writing these lines it's the year 2024. I started to use Linux in my youth and also started to code at the same time. That is nearly 20 years in the past now. So I may claim that I've been doing software development for 15+ years. In university, around 2011, I started to write software as a research assistant. Since 2014 (ten years) I've been doing embedded software development as my main job and can call myself a professional software developer. In all these years I have already seen a lot of programming languages, projects and problems. Multi repository problem (2015) In 2015 at my first embedded software development job I encountered the multi repository problem. The company was on the way to migrate the embedded build system for their Linux distribution and firmware images to Yocto. Back then I started to learn and use the repo tool by Google to manage projects with multiple repositories. While doing the first releases of the Linux firmware, I noticed the weaknesses of using repo. Everything that is easy with a single repository like checking out branches of a coworker, switching between different development branches (stable vs main), bisecting errors and making a release and tagging becomes a major hassle with multiple repositories and the repo tool. And it's very error prone. At that time I started a new hobby project called rap . The solution is inside a git repo (2015) So I'm working on a better version of the repo, called rap , for three months. It should be repo by Google done right. I wrote it in python and at the end it consists of 2889 lines of code for the program and 985 lines of tests. It should support features, like easy checkout of multiple repos, bisecting across multiple repos and git bundles across multi repos. After the three months I noticed that I was building a version control system for git repositories. And git is itself a version control system. That is duplicate and useless work. This brought me to the first learning: ( L1 ) The solution to the multi repository problem is inside of git (or generally inside any version control system). The solution is not writing a new version control system to manage version control systems. So I abandoned the rap project and looked at existing solutions that allow me to manage multiple repositories inside a git repo. Most people know git submodules , but there is also git subtree . Documentation, documentation and documentation (2015) I already knew git submodules and also knew that has its own set of usability challenges. So I looked at git subtree and its subtree merge strategy . Maybe it's a viable solution. After trying it out I noticed that the documentation is lacking. I started to write additional documentation for it and called the project Handbook of Applied git subtree merge . The problem is explaining the problem to developers and explaining how the tool works to solve the management problem. This can be summarized up in the learning: ( L2 ) Good documentation is very very important. Quickly after that I also noticed that the tooling of git subtree is inadequate. Only additional documentation will not fix usability issues. The third learning is: ( L3 ) Good documentation with good tooling is the key. Better Tooling (2016) In 2016 I started to work on better tooling for git subtree. I called the project git-subtreemerge . It should be git subtree done right. A better tool to perform and help the user to use the subtree merge strategy of git. I worked on this project from June 2016 to May 2017 (roughly eight months) in my spare time. At the end the project consist of 5027 lines of python code for the program and 9544 lines of python code lines are tests. So 65% percent of all the code are tests. At this stage the basic features were working in the tool and I wanted to release it as a prototype. So I started to work on the documentation that explains how the tool works and the theory behind it. I quickly noticed that this would not fly. It's not about the accidental complexity of the git subtree merge strategy or the tool. It's about the essential or inherent complexity of it. The core problem is that the merge strategy is mixing commits of the subproject into the history (the commit graph) of the superproject. If you have multiple subprojects, then you also have multiple different types of subproject commits in the history of the superproject. Combine this with changes to the subproject in the superproject and combine this with merges (different development branches) in the superproject, you get a complexity explosion of everything that can happen and must be explained. In fact there are mathematical underlying properties, embeddings and commutative operations, for this. So in general it's sound. But this setup is not explainable to even experienced git users. At this point I abandoned the project. My main learning was ( L4 ) Use the right design to minimize the inherent complexity to avoid accidental complexity. To phrase it for the git subtree merge strategy. It has a huge inherent complexity, which is way too big for the essential complexity of the multi repository management problem. Gerrit and repo (2018) In 2018 I had the chance to work on a project that uses the Gerrit Code Review System together with the repo tool. I did expect the same problems as in the year 2016, but gave the combination of gerrit plus repo another try. Summary: It's still madness. Even simple things like checking out the branches of a coworker is non-trivial. It's not supported by the repo tool. We started to implement our own tool called repoload for that. At least Gerrit supports submitting/accepting cross atomic commits. That's a feature you need when you start to distribute your project across multiple git repos. The documentation Submitting Changes Across Repositories by using Topics . So Gerrit has the cross repo atomic commit feature. Sadly our continuous integration system (CI), Jenkins in this case, did not. Our project rolled out its own implementation based on the Change-Id and Depends-On fields in the commit messages. Written in a combination of bash and groovy. Also madness. There were a couple of other learnings from this project which I can summarize up as: ( L5 ) The build process must stay inside of a single repository. You can also phrase it differently. When you or your CI system must checkout multiple git repos, that you own, for building the project, you are doing it wrong. git add and linear patch stacks (2018+) In the same project we used a different solution (not repo or git submodules) for a small component. We integrated a C++ dependency into the git repository with git add . We just added the source files in a single commit into the project. We even applied local patches to the project as normal git commits on top of it. When upgrading the dependency we removed the original files, added the new source files and reapplied the patches with git cherry-pick . That process worked nicely. The learning is: ( L6 ) The only sane way to maintain a downstream fork is a linear patch stack (=series of patches). And that is actually a very old thing. Linux distributions, like the big ones for the desktop but also for embedded devices, maintain a linear patch stack for their packages (=source dependencies). It's a process that has been done for decades now. One last thing One last learning that also feeds into subpatch is ( L7 ) Good development practices, like atomic commits, must still be possible with the multi repository management tool. Even across the used subprojects. Conclusion That is my history of the multi repository problem. Hopefully it shows that the following requirements and design decision are not an ad-hoc idea, but instead based on a long period of experience and tackling the multi repository problem from different angles. If you want to find out more now, you can jump to the requirements page . Based on the learnings above it sketches out the design of a new tool.","title":"Learnings"},{"location":"exp/learnings/#learnings","text":"On the previous introductions page , you could read about the basics of the multi repository problem. subpatch is not my first attempt to solve the multi repository problem. There is a long history before I started the subpatch project. This page should tell the history and what learnings I made along the way. lt;dr: The summary of all learnings is ( L1 ) The solution to the multi repository problem is inside of git (or generally inside any version control system). ( L2 ) Good documentation is very very important. ( L3 ) Good documentation with good tooling is the key. ( L4 ) Use the right design to minimize the inherent complexity to avoid accidental complexity. ( L5 ) The build process must stay inside of a single repository. ( L6 ) The only sane way to maintain a downstream fork is a linear patch stack (=series of patches). ( L7 ) Good development practices, like atomic commits, must still be possible with the multi repository management tool. Even across the used subprojects.","title":"Learnings"},{"location":"exp/learnings/#personal-history","text":"While writing these lines it's the year 2024. I started to use Linux in my youth and also started to code at the same time. That is nearly 20 years in the past now. So I may claim that I've been doing software development for 15+ years. In university, around 2011, I started to write software as a research assistant. Since 2014 (ten years) I've been doing embedded software development as my main job and can call myself a professional software developer. In all these years I have already seen a lot of programming languages, projects and problems.","title":"Personal history"},{"location":"exp/learnings/#multi-repository-problem-2015","text":"In 2015 at my first embedded software development job I encountered the multi repository problem. The company was on the way to migrate the embedded build system for their Linux distribution and firmware images to Yocto. Back then I started to learn and use the repo tool by Google to manage projects with multiple repositories. While doing the first releases of the Linux firmware, I noticed the weaknesses of using repo. Everything that is easy with a single repository like checking out branches of a coworker, switching between different development branches (stable vs main), bisecting errors and making a release and tagging becomes a major hassle with multiple repositories and the repo tool. And it's very error prone. At that time I started a new hobby project called rap .","title":"Multi repository problem (2015)"},{"location":"exp/learnings/#the-solution-is-inside-a-git-repo-2015","text":"So I'm working on a better version of the repo, called rap , for three months. It should be repo by Google done right. I wrote it in python and at the end it consists of 2889 lines of code for the program and 985 lines of tests. It should support features, like easy checkout of multiple repos, bisecting across multiple repos and git bundles across multi repos. After the three months I noticed that I was building a version control system for git repositories. And git is itself a version control system. That is duplicate and useless work. This brought me to the first learning: ( L1 ) The solution to the multi repository problem is inside of git (or generally inside any version control system). The solution is not writing a new version control system to manage version control systems. So I abandoned the rap project and looked at existing solutions that allow me to manage multiple repositories inside a git repo. Most people know git submodules , but there is also git subtree .","title":"The solution is inside a git repo (2015)"},{"location":"exp/learnings/#documentation-documentation-and-documentation-2015","text":"I already knew git submodules and also knew that has its own set of usability challenges. So I looked at git subtree and its subtree merge strategy . Maybe it's a viable solution. After trying it out I noticed that the documentation is lacking. I started to write additional documentation for it and called the project Handbook of Applied git subtree merge . The problem is explaining the problem to developers and explaining how the tool works to solve the management problem. This can be summarized up in the learning: ( L2 ) Good documentation is very very important. Quickly after that I also noticed that the tooling of git subtree is inadequate. Only additional documentation will not fix usability issues. The third learning is: ( L3 ) Good documentation with good tooling is the key.","title":"Documentation, documentation and documentation (2015)"},{"location":"exp/learnings/#better-tooling-2016","text":"In 2016 I started to work on better tooling for git subtree. I called the project git-subtreemerge . It should be git subtree done right. A better tool to perform and help the user to use the subtree merge strategy of git. I worked on this project from June 2016 to May 2017 (roughly eight months) in my spare time. At the end the project consist of 5027 lines of python code for the program and 9544 lines of python code lines are tests. So 65% percent of all the code are tests. At this stage the basic features were working in the tool and I wanted to release it as a prototype. So I started to work on the documentation that explains how the tool works and the theory behind it. I quickly noticed that this would not fly. It's not about the accidental complexity of the git subtree merge strategy or the tool. It's about the essential or inherent complexity of it. The core problem is that the merge strategy is mixing commits of the subproject into the history (the commit graph) of the superproject. If you have multiple subprojects, then you also have multiple different types of subproject commits in the history of the superproject. Combine this with changes to the subproject in the superproject and combine this with merges (different development branches) in the superproject, you get a complexity explosion of everything that can happen and must be explained. In fact there are mathematical underlying properties, embeddings and commutative operations, for this. So in general it's sound. But this setup is not explainable to even experienced git users. At this point I abandoned the project. My main learning was ( L4 ) Use the right design to minimize the inherent complexity to avoid accidental complexity. To phrase it for the git subtree merge strategy. It has a huge inherent complexity, which is way too big for the essential complexity of the multi repository management problem.","title":"Better Tooling (2016)"},{"location":"exp/learnings/#gerrit-and-repo-2018","text":"In 2018 I had the chance to work on a project that uses the Gerrit Code Review System together with the repo tool. I did expect the same problems as in the year 2016, but gave the combination of gerrit plus repo another try. Summary: It's still madness. Even simple things like checking out the branches of a coworker is non-trivial. It's not supported by the repo tool. We started to implement our own tool called repoload for that. At least Gerrit supports submitting/accepting cross atomic commits. That's a feature you need when you start to distribute your project across multiple git repos. The documentation Submitting Changes Across Repositories by using Topics . So Gerrit has the cross repo atomic commit feature. Sadly our continuous integration system (CI), Jenkins in this case, did not. Our project rolled out its own implementation based on the Change-Id and Depends-On fields in the commit messages. Written in a combination of bash and groovy. Also madness. There were a couple of other learnings from this project which I can summarize up as: ( L5 ) The build process must stay inside of a single repository. You can also phrase it differently. When you or your CI system must checkout multiple git repos, that you own, for building the project, you are doing it wrong.","title":"Gerrit and repo (2018)"},{"location":"exp/learnings/#git-add-and-linear-patch-stacks-2018","text":"In the same project we used a different solution (not repo or git submodules) for a small component. We integrated a C++ dependency into the git repository with git add . We just added the source files in a single commit into the project. We even applied local patches to the project as normal git commits on top of it. When upgrading the dependency we removed the original files, added the new source files and reapplied the patches with git cherry-pick . That process worked nicely. The learning is: ( L6 ) The only sane way to maintain a downstream fork is a linear patch stack (=series of patches). And that is actually a very old thing. Linux distributions, like the big ones for the desktop but also for embedded devices, maintain a linear patch stack for their packages (=source dependencies). It's a process that has been done for decades now.","title":"git add and linear patch stacks (2018+)"},{"location":"exp/learnings/#one-last-thing","text":"One last learning that also feeds into subpatch is ( L7 ) Good development practices, like atomic commits, must still be possible with the multi repository management tool. Even across the used subprojects.","title":"One last thing"},{"location":"exp/learnings/#conclusion","text":"That is my history of the multi repository problem. Hopefully it shows that the following requirements and design decision are not an ad-hoc idea, but instead based on a long period of experience and tackling the multi repository problem from different angles. If you want to find out more now, you can jump to the requirements page . Based on the learnings above it sketches out the design of a new tool.","title":"Conclusion"},{"location":"exp/requirements/","text":"Requirements I based subpatch on my experiences and learnings as a (embedded) software engineer. Everything that I have seen and done in the last ten years feeds into the following list of requirements. See the learnings for details. Note : For now the implementation of subpatch not complete. Please read the requirement list as a vision for the first major release of subpatch, not as a status of the implementation. List of requirements The tool \u2026 ( R1 ) should support git as the primary scm tool for the superproject and cvs, mercurial, subversion and non-scm environment as functional but limited superprojects. ( R2 ) do not interfere with the vcs. The existing workflows like checking out, cloning, switching branches, updating, rebasing, tagging, forking, bisecting, releasing and \u2026 should stay the same. ( R3 ) should support git, cvs, mercurial, subversion and source code archives (like tarballs or zip files) as source dependencies/subprojects. ( R4 ) should track the original metadata (e.g. url, commit ids, checksums, \u2026 ) of the source dependency to verify the authenticity of the dependency later. ( R5 ) should help integrating updates of the source dependencies. ( R6 ) should support local patching of source dependencies. ( R7 ) If the source dependency is patched locally, it should help maintaining a linear patch stack. ( R8 ) should rebase local patches automatically, when doing an update of a source dependency and there are no conflicts with the local patches. ( R9 ) should help porting the local patches, when doing an update of a source dependency and there are conflicts with the local patches. ( R10 ) should provided an stable command line API (plumbing commands) to support other tools to track source dependencies, e.g. to automatically check for updates or for CVEs. ( R11 ) should support every development platform that also supports git and python, like Linux, unixes, Windows and MacOS. ( R12 ) should scale to the size of the AOSP (Android Open Source Project). Change history Update to R1 on 2025-01-12: subpatch only supports git as a superproject with all features. Background: The requirement R1 was modified. Not all scm tools are supported fully anymore. The full functionality will only be available if the superproject is a git repository. Reasons: Avoid rewriting existing functionality, e.g. applying patches, calculating a tree checksum, maintaining and listing tracked (and non-tracked) files. If the superproject is not git or not a scm at all, these functions need to be implemented in subpatch. Why reimplementing existing functionality? This learning I had already in the past. See learning L1 on learnings : The solution is inside a scm tool. subpatch should not try or need to reimplementing existing functionality. Conclusion The list of requirements is the design goal of subpatch. It describes the properties and capabilities an implementation should fulfil and provide for its users. If you want to find more about the development and implementation, you can continue reading on the page design decisions .","title":"Requirements"},{"location":"exp/requirements/#requirements","text":"I based subpatch on my experiences and learnings as a (embedded) software engineer. Everything that I have seen and done in the last ten years feeds into the following list of requirements. See the learnings for details. Note : For now the implementation of subpatch not complete. Please read the requirement list as a vision for the first major release of subpatch, not as a status of the implementation.","title":"Requirements"},{"location":"exp/requirements/#list-of-requirements","text":"The tool \u2026 ( R1 ) should support git as the primary scm tool for the superproject and cvs, mercurial, subversion and non-scm environment as functional but limited superprojects. ( R2 ) do not interfere with the vcs. The existing workflows like checking out, cloning, switching branches, updating, rebasing, tagging, forking, bisecting, releasing and \u2026 should stay the same. ( R3 ) should support git, cvs, mercurial, subversion and source code archives (like tarballs or zip files) as source dependencies/subprojects. ( R4 ) should track the original metadata (e.g. url, commit ids, checksums, \u2026 ) of the source dependency to verify the authenticity of the dependency later. ( R5 ) should help integrating updates of the source dependencies. ( R6 ) should support local patching of source dependencies. ( R7 ) If the source dependency is patched locally, it should help maintaining a linear patch stack. ( R8 ) should rebase local patches automatically, when doing an update of a source dependency and there are no conflicts with the local patches. ( R9 ) should help porting the local patches, when doing an update of a source dependency and there are conflicts with the local patches. ( R10 ) should provided an stable command line API (plumbing commands) to support other tools to track source dependencies, e.g. to automatically check for updates or for CVEs. ( R11 ) should support every development platform that also supports git and python, like Linux, unixes, Windows and MacOS. ( R12 ) should scale to the size of the AOSP (Android Open Source Project).","title":"List of requirements"},{"location":"exp/requirements/#change-history","text":"Update to R1 on 2025-01-12: subpatch only supports git as a superproject with all features. Background: The requirement R1 was modified. Not all scm tools are supported fully anymore. The full functionality will only be available if the superproject is a git repository. Reasons: Avoid rewriting existing functionality, e.g. applying patches, calculating a tree checksum, maintaining and listing tracked (and non-tracked) files. If the superproject is not git or not a scm at all, these functions need to be implemented in subpatch. Why reimplementing existing functionality? This learning I had already in the past. See learning L1 on learnings : The solution is inside a scm tool. subpatch should not try or need to reimplementing existing functionality.","title":"Change history"},{"location":"exp/requirements/#conclusion","text":"The list of requirements is the design goal of subpatch. It describes the properties and capabilities an implementation should fulfil and provide for its users. If you want to find more about the development and implementation, you can continue reading on the page design decisions .","title":"Conclusion"},{"location":"howto/yocto/","text":"Project based on Yocto This how-to guide explains how to use subpatch to maintain an embedded Linux firmware based on the Yocto project . A full feature example of a Yocto project maintained with subpatch is available here: yocto-example Note: There are maybe some mistakes in the following commands. There are no automated tests yet. Prerequisites This how-to guide is not a tutorial. You should have install subpatch already and learned the basic usage of subpatch. If not, please work trough the tutorials. The preconditions are subpatch installed Basic usage of subpatch known Basic usage of Yocto known Adding poky First you need add the poky repository. This how-to guide adds all layers in a sub directory called sources . You may also just add the repos at the toplevel directory. This guide uses a fresh git repository, but you can also use a existing one. Execute: $ git init $ mkdir sources $ cd sources $ subpatch add https://git.yoctoproject.org/poky -r scarthgap $ git commit -m \"adding poky\" The above commands add poky from the branch scarthgap into the directory sources/poky/ . At the time of writing, this branch is the latest long term support branch. See Releases on the Yocto wiki for more details. Now you can already initialize the build environment: $ cd .. $ . sources/poky/oe-init-build-env This will create a build directory with the default configurations for local.conf and bblayers.conf Adding additional layers To find recipes and layers you can use the OpenEmbedded Layer Index . When you want to add a layer, you use subpatch's add command . The following example adds the git repository meta-openembedded that contains multiple layers: # Starting in the `build/` subdirectory $ cd ../sources $ subpatch add git://git.openembedded.org/meta-openembedded -r scarthgap $ git commit -m \"add meta-openembedded\" subpatch adds all files of the layer in the directory sources/meta-openembedded . After that, you can update your bblayers.conf to include the new layer(s). $ cd ../build $ bitbake-layers add-layer ../meta-openembedded/meta-oe $ bitbake-layers add-layer ../meta-openembedded/meta-python Repeat this for all external layers you want to add. Adding your own layer To maintain your local recipes, bbappends, distro and default build configuration it's good to add your own layer. This example calls the layer mylayer and places it next to poky into the sources/ subdirectory. # Starting in the `build/` subdirectory $ bitbake-layers create-layer ../sources/meta-mylayer Don't forget to add this layer to your bblayers.conf and to commit your changes $ bitbake-layers add-layer ../sources/meta-mylayer $ git add ../sources/meta-mylayer $ git commit -m \"add mylayer\" See Understanding and Creating Layers and Creating a new BSP Layer Using the bitbake-layers Script in the official Yocto documentation for further details. Adding default build configuration To share your local.conf and bblayers.conf with other developers, you can store a default local.conf and bblayers.conf in our own layer. # Starting in the `build/` subdirectory $ bitbake-layers save-build-conf ../sources/meta-mylayer/ myconf The above command stores the template config in the directory sources/meta-mylayer/conf/templates/myconf/ . To share it with other developers also commit it: $ git add ../sources/meta-mylayer/conf/templates/myconf/ $ git commit -m \"add my template\" New developers can use the following command to initialized their build configuration from the template after a fresh checkout of the superproject. $ TEMPLATECONF=../meta-mylayer/conf/templates/myconf . sources/poky/oe-init-build-env See Creating a Custom Template Configuration Directory in the official Yocto Documentation for more details. Updating layers to a new stable release From time to time you should update the subprojects (= the Yocto layers and poky) to the newest stable version. For Yocto layers it means to update to the newest commit on the specific stable branch. For that you can use subpatch's update command. First get an overview of all the subprojects (=layers and poky in this how-to) the superproject uses: # In the toplevel directory $ subpatch list # and for more information about the subprojects $ subpatch status Then you can update every layer one by one. $ subpatch update sources/poky $ git commit -m \"updating poky\" $ subpatch update sources/meta-openembedded $ git commit -m \"updating meta-openembedded Before publishing your changes for review, you should make a local build and run some smoke tests of course. Note 1 : For now subpatch does not have a foreach command. So you need to update every layer separately. Note 2 : For now subpatch does not have a update --dry-run command. So just checking for updates means downloading the remote repository. subpatch already uses --depth 1 , but it can be a expensive network operation nevertheless. How to make a release If you want to make a release of your firmware, you can just tag the superproject like any project that is using git. Of course your project setup may need additional steps, e.g. updating a version number or adding release notes. But since subpatch is only an addition to git, you can use the standard git workflow for releasing. Some example commands: # Increase version number $ vim sources/meta-mylayer/ TODO add file here $ git commit -a -m \"Makeing release vX.Y\" $ git tag -m \"release vX.Y vX.Y $ git push --follow-tags --dry-run $ git push --follow-tags Upgrading to a new release branch To update all layers to a new release branch, e.g., from scarthgap to styhead , you can also use subpatch's update command. First execute $ subpatch status It will list all subprojects with additional information, e.g. the upstream branch that the subproject uses. You can update to a new release branch with $ subpatch update sources/poky -r styhead $ subpatch update sources/meta-openembedded -r styhead $ git commit -m \"upgrade to new release branch\" In all cases this major upgrade requires additional changes in your layer and additional testing.","title":"Project based on Yocto"},{"location":"howto/yocto/#project-based-on-yocto","text":"This how-to guide explains how to use subpatch to maintain an embedded Linux firmware based on the Yocto project . A full feature example of a Yocto project maintained with subpatch is available here: yocto-example Note: There are maybe some mistakes in the following commands. There are no automated tests yet.","title":"Project based on Yocto"},{"location":"howto/yocto/#prerequisites","text":"This how-to guide is not a tutorial. You should have install subpatch already and learned the basic usage of subpatch. If not, please work trough the tutorials. The preconditions are subpatch installed Basic usage of subpatch known Basic usage of Yocto known","title":"Prerequisites"},{"location":"howto/yocto/#adding-poky","text":"First you need add the poky repository. This how-to guide adds all layers in a sub directory called sources . You may also just add the repos at the toplevel directory. This guide uses a fresh git repository, but you can also use a existing one. Execute: $ git init $ mkdir sources $ cd sources $ subpatch add https://git.yoctoproject.org/poky -r scarthgap $ git commit -m \"adding poky\" The above commands add poky from the branch scarthgap into the directory sources/poky/ . At the time of writing, this branch is the latest long term support branch. See Releases on the Yocto wiki for more details. Now you can already initialize the build environment: $ cd .. $ . sources/poky/oe-init-build-env This will create a build directory with the default configurations for local.conf and bblayers.conf","title":"Adding poky"},{"location":"howto/yocto/#adding-additional-layers","text":"To find recipes and layers you can use the OpenEmbedded Layer Index . When you want to add a layer, you use subpatch's add command . The following example adds the git repository meta-openembedded that contains multiple layers: # Starting in the `build/` subdirectory $ cd ../sources $ subpatch add git://git.openembedded.org/meta-openembedded -r scarthgap $ git commit -m \"add meta-openembedded\" subpatch adds all files of the layer in the directory sources/meta-openembedded . After that, you can update your bblayers.conf to include the new layer(s). $ cd ../build $ bitbake-layers add-layer ../meta-openembedded/meta-oe $ bitbake-layers add-layer ../meta-openembedded/meta-python Repeat this for all external layers you want to add.","title":"Adding additional layers"},{"location":"howto/yocto/#adding-your-own-layer","text":"To maintain your local recipes, bbappends, distro and default build configuration it's good to add your own layer. This example calls the layer mylayer and places it next to poky into the sources/ subdirectory. # Starting in the `build/` subdirectory $ bitbake-layers create-layer ../sources/meta-mylayer Don't forget to add this layer to your bblayers.conf and to commit your changes $ bitbake-layers add-layer ../sources/meta-mylayer $ git add ../sources/meta-mylayer $ git commit -m \"add mylayer\" See Understanding and Creating Layers and Creating a new BSP Layer Using the bitbake-layers Script in the official Yocto documentation for further details.","title":"Adding your own layer"},{"location":"howto/yocto/#adding-default-build-configuration","text":"To share your local.conf and bblayers.conf with other developers, you can store a default local.conf and bblayers.conf in our own layer. # Starting in the `build/` subdirectory $ bitbake-layers save-build-conf ../sources/meta-mylayer/ myconf The above command stores the template config in the directory sources/meta-mylayer/conf/templates/myconf/ . To share it with other developers also commit it: $ git add ../sources/meta-mylayer/conf/templates/myconf/ $ git commit -m \"add my template\" New developers can use the following command to initialized their build configuration from the template after a fresh checkout of the superproject. $ TEMPLATECONF=../meta-mylayer/conf/templates/myconf . sources/poky/oe-init-build-env See Creating a Custom Template Configuration Directory in the official Yocto Documentation for more details.","title":"Adding default build configuration"},{"location":"howto/yocto/#updating-layers-to-a-new-stable-release","text":"From time to time you should update the subprojects (= the Yocto layers and poky) to the newest stable version. For Yocto layers it means to update to the newest commit on the specific stable branch. For that you can use subpatch's update command. First get an overview of all the subprojects (=layers and poky in this how-to) the superproject uses: # In the toplevel directory $ subpatch list # and for more information about the subprojects $ subpatch status Then you can update every layer one by one. $ subpatch update sources/poky $ git commit -m \"updating poky\" $ subpatch update sources/meta-openembedded $ git commit -m \"updating meta-openembedded Before publishing your changes for review, you should make a local build and run some smoke tests of course. Note 1 : For now subpatch does not have a foreach command. So you need to update every layer separately. Note 2 : For now subpatch does not have a update --dry-run command. So just checking for updates means downloading the remote repository. subpatch already uses --depth 1 , but it can be a expensive network operation nevertheless.","title":"Updating layers to a new stable release"},{"location":"howto/yocto/#how-to-make-a-release","text":"If you want to make a release of your firmware, you can just tag the superproject like any project that is using git. Of course your project setup may need additional steps, e.g. updating a version number or adding release notes. But since subpatch is only an addition to git, you can use the standard git workflow for releasing. Some example commands: # Increase version number $ vim sources/meta-mylayer/ TODO add file here $ git commit -a -m \"Makeing release vX.Y\" $ git tag -m \"release vX.Y vX.Y $ git push --follow-tags --dry-run $ git push --follow-tags","title":"How to make a release"},{"location":"howto/yocto/#upgrading-to-a-new-release-branch","text":"To update all layers to a new release branch, e.g., from scarthgap to styhead , you can also use subpatch's update command. First execute $ subpatch status It will list all subprojects with additional information, e.g. the upstream branch that the subproject uses. You can update to a new release branch with $ subpatch update sources/poky -r styhead $ subpatch update sources/meta-openembedded -r styhead $ git commit -m \"upgrade to new release branch\" In all cases this major upgrade requires additional changes in your layer and additional testing.","title":"Upgrading to a new release branch"},{"location":"ref/command-line/","text":"Command line arguments The subpatch command line tool uses the common argument structure with multiple arguments and one command. It is the same as other popular tools like git or docker . Examples: subpatch status subpatch add <url> -r <revision> Here status and add are commands and -r <revision> is an optional argument. subpatch uses the argparse module of python. So the following commands are equivalent: subpatch add -r=<revision> <url> subpatch add -r<revision> <url> subpatch add -r <revision> <url> subpatch add <url> --revision=<revision> subpatch add <url> --revision <revision> Common arguments This paragraph explains the common arguments that are used by multiple commands: -q,--quiet : Suppress any output to stdout. subpatch list subpatch list Print the path of all subprojects in the repository. subpatch status subpatch status Show the current state of all subprojects in the superproject. It prints the URL, integrated revision and whether the files of the subproject are changed. E.g. if there are untracked files, unstaged changes or staged, but uncommitted changes. It's similar to git status , but not for the whole repository. Only for the subprojects. subpatch add subpatch add <url> [<path>] [-r | --revision <revision>] [-q | --quiet] Add the remote project specified by url as a subproject at the optional path in the current repository. Currently url can only point to a git repository. Other subproject types are not supported yet. The path is optional. If it's omitted the canonical subproject name is used. It's mostly the last folder name in the url . If path is provided it can include also sub directories. If no --revision argument is given, subpatch uses the remote default branch for git repositories. It's mostly the main branch, but the remote repository can configured also different branches as the default HEAD . -r,--revision : Specify the revision of the subproject that should be included in the superproject. For git repositories it can be a branch name, a tag name or a commit id. For performance you should give a branch name or tag name. The git protocol allows to clone a single branch or tag efficiently. For git commit ids subpatch needs to download the whole repository including all branches, tags and the complete history instead of just a single revision. subpatch update subpatch update <path> [--revision | -r <revision>] [--url | -r <url>] Update the subproject at path . subpatch downloads the remote repository at url and unpacks the source files specified by the revision . All existing and tracked files of the subproject are removed and replaced by the downloaded files. If no --revision argument is given, subpatch uses the value from the config. Otherwise subpatch uses the new revision from the command line and updates the value in the config. If no --url argument is given, subpatch uses the value from the config. Otherwise subpatch uses the new url from the command line and updates the value in the config. subpatch configure subpatch configure [-q | --quiet] Configure the current superproject to use subpatch. The command adds the .subpatch config file at toplevel directory of the superproject. subpatch uses the existens of this file as a marker that the project is using subpatch. This command works only for git repositories as superprojects currently. subpatch does not support other SCM tools or plain directories for now. Normally you do not have to execute this command. subpatch add automatically configures the superproject if necessary. subpatch apply subpatch configure [-q | --quiet] <patch file> Apply the patch in the patch file to the current subproject. The code changes in the patch are applied onto the source code in the directory and the patch file is stored in the patches subdirectory. You select the subproject by changing the current work directory into the subproject. subpatch pop|push subpatch pop|push [-q | --quiet] Pop or push the top most applied patch of the current subproject. The code changes are reverted (for pop ) or applied (for push ) to the working tree of the subproject. subpatch records the current state of applied or not applied patches in the metadata. You select the subproject by changing the current work directory into the subproject. Commands, not implemented yet The following list is a draft for additional commands. subpatch will implement these in that form or another. rm <subproject> : Remove subproject code and config data. The reverse of add . mv <subproject> <new directory for subproject> : Move/rename subproject to a new directory and update the config data foreach <command> : Execute a shell command for every subproject. All the other multi repository management tools also have such a command. So subpatch also needs it. See repo foreach and git submodule foreach check : Verify subproject source code, patches and config check that subpatch config/subproject config is valid/consistent check that patches can be reverted to obtain the original source code check that a superproject diff/patch/commit-range does not break the invariants. (This should be used in the CI) reformat : reformat the subpatch config a consistent way. There also will be some sort of --check argument to verify the style in a CI pipeline. create-patches : from the last or multiple last commits of the subproject, create patches for the subproject, to fullfill the invariant. root : Show the root path of the superproject. Useful for something like croot in the AOSP. For git the command looks like git rev-parse --show-toplevel .","title":"Command line arguments"},{"location":"ref/command-line/#command-line-arguments","text":"The subpatch command line tool uses the common argument structure with multiple arguments and one command. It is the same as other popular tools like git or docker . Examples: subpatch status subpatch add <url> -r <revision> Here status and add are commands and -r <revision> is an optional argument. subpatch uses the argparse module of python. So the following commands are equivalent: subpatch add -r=<revision> <url> subpatch add -r<revision> <url> subpatch add -r <revision> <url> subpatch add <url> --revision=<revision> subpatch add <url> --revision <revision>","title":"Command line arguments"},{"location":"ref/command-line/#common-arguments","text":"This paragraph explains the common arguments that are used by multiple commands: -q,--quiet : Suppress any output to stdout.","title":"Common arguments"},{"location":"ref/command-line/#subpatch-list","text":"subpatch list Print the path of all subprojects in the repository.","title":"subpatch list"},{"location":"ref/command-line/#subpatch-status","text":"subpatch status Show the current state of all subprojects in the superproject. It prints the URL, integrated revision and whether the files of the subproject are changed. E.g. if there are untracked files, unstaged changes or staged, but uncommitted changes. It's similar to git status , but not for the whole repository. Only for the subprojects.","title":"subpatch status"},{"location":"ref/command-line/#subpatch-add","text":"subpatch add <url> [<path>] [-r | --revision <revision>] [-q | --quiet] Add the remote project specified by url as a subproject at the optional path in the current repository. Currently url can only point to a git repository. Other subproject types are not supported yet. The path is optional. If it's omitted the canonical subproject name is used. It's mostly the last folder name in the url . If path is provided it can include also sub directories. If no --revision argument is given, subpatch uses the remote default branch for git repositories. It's mostly the main branch, but the remote repository can configured also different branches as the default HEAD . -r,--revision : Specify the revision of the subproject that should be included in the superproject. For git repositories it can be a branch name, a tag name or a commit id. For performance you should give a branch name or tag name. The git protocol allows to clone a single branch or tag efficiently. For git commit ids subpatch needs to download the whole repository including all branches, tags and the complete history instead of just a single revision.","title":"subpatch add"},{"location":"ref/command-line/#subpatch-update","text":"subpatch update <path> [--revision | -r <revision>] [--url | -r <url>] Update the subproject at path . subpatch downloads the remote repository at url and unpacks the source files specified by the revision . All existing and tracked files of the subproject are removed and replaced by the downloaded files. If no --revision argument is given, subpatch uses the value from the config. Otherwise subpatch uses the new revision from the command line and updates the value in the config. If no --url argument is given, subpatch uses the value from the config. Otherwise subpatch uses the new url from the command line and updates the value in the config.","title":"subpatch update"},{"location":"ref/command-line/#subpatch-configure","text":"subpatch configure [-q | --quiet] Configure the current superproject to use subpatch. The command adds the .subpatch config file at toplevel directory of the superproject. subpatch uses the existens of this file as a marker that the project is using subpatch. This command works only for git repositories as superprojects currently. subpatch does not support other SCM tools or plain directories for now. Normally you do not have to execute this command. subpatch add automatically configures the superproject if necessary.","title":"subpatch configure"},{"location":"ref/command-line/#subpatch-apply","text":"subpatch configure [-q | --quiet] <patch file> Apply the patch in the patch file to the current subproject. The code changes in the patch are applied onto the source code in the directory and the patch file is stored in the patches subdirectory. You select the subproject by changing the current work directory into the subproject.","title":"subpatch apply"},{"location":"ref/command-line/#subpatch-poppush","text":"subpatch pop|push [-q | --quiet] Pop or push the top most applied patch of the current subproject. The code changes are reverted (for pop ) or applied (for push ) to the working tree of the subproject. subpatch records the current state of applied or not applied patches in the metadata. You select the subproject by changing the current work directory into the subproject.","title":"subpatch pop|push"},{"location":"ref/command-line/#commands-not-implemented-yet","text":"The following list is a draft for additional commands. subpatch will implement these in that form or another. rm <subproject> : Remove subproject code and config data. The reverse of add . mv <subproject> <new directory for subproject> : Move/rename subproject to a new directory and update the config data foreach <command> : Execute a shell command for every subproject. All the other multi repository management tools also have such a command. So subpatch also needs it. See repo foreach and git submodule foreach check : Verify subproject source code, patches and config check that subpatch config/subproject config is valid/consistent check that patches can be reverted to obtain the original source code check that a superproject diff/patch/commit-range does not break the invariants. (This should be used in the CI) reformat : reformat the subpatch config a consistent way. There also will be some sort of --check argument to verify the style in a CI pipeline. create-patches : from the last or multiple last commits of the subproject, create patches for the subproject, to fullfill the invariant. root : Show the root path of the superproject. Useful for something like croot in the AOSP. For git the command looks like git rev-parse --show-toplevel .","title":"Commands, not implemented yet"},{"location":"ref/fosdem25/","text":"FOSDEM 25 This page is for my lighting talk at the FOSDEM 25 . The recordings are available here: video in webm format video in mp4 format Call to action Please read the website, try out the prototype and provide feedback, you can join the matrix room #subpatch:matrix.org , open an issue on github or email me . Thanks! Lighting Talk Content: Present call to action Present homepage of subpatch (Maybe) Do a showcase Repeat call to action :-)","title":"FOSDEM 25"},{"location":"ref/fosdem25/#fosdem-25","text":"This page is for my lighting talk at the FOSDEM 25 . The recordings are available here: video in webm format video in mp4 format","title":"FOSDEM 25"},{"location":"ref/fosdem25/#call-to-action","text":"Please read the website, try out the prototype and provide feedback, you can join the matrix room #subpatch:matrix.org , open an issue on github or email me . Thanks!","title":"Call to action"},{"location":"ref/fosdem25/#lighting-talk","text":"Content: Present call to action Present homepage of subpatch (Maybe) Do a showcase Repeat call to action :-)","title":"Lighting Talk"},{"location":"ref/froscon25/","text":"FrOSCon 25 This page is for my talk \"subpatch: fearless multi repository management\" at the FrOSCon 25 . Call to action tbd Content of the talk Content: tbd","title":"FrOSCon 25"},{"location":"ref/froscon25/#froscon-25","text":"This page is for my talk \"subpatch: fearless multi repository management\" at the FrOSCon 25 .","title":"FrOSCon 25"},{"location":"ref/froscon25/#call-to-action","text":"tbd","title":"Call to action"},{"location":"ref/froscon25/#content-of-the-talk","text":"Content: tbd","title":"Content of the talk"},{"location":"ref/glossary/","text":"Glossary This page contains explanations of the terms in the context subpatch. The terms are not sorted alphabetically. They are sorted according to relevance. More important terms are at the top, less important terms are at the bottom. multi repository management/setup/problem The multi repository problem is when your project consists of multiple repositories and there are interdependencies between these repositories. E.g. when you must checkout multiple repos, because your build spans across multiple On this website the problem is sometimes called multi repository setup . The process of handling such a project is called multi repository management . superproject The superproject is the parent project in a multi repository setup. It's often a git repository itself, e.g. for git submodule . When using subpatch the superproject has the configuration file .subpatch at its top level directory. subproject(s) The subproject or subprojects are the external projects, often called (third party) dependencies, that are added to the superproject. Note : The terms super- and sub- projects are always relative to a specific project setup. It might be the case that the superproject of a project (e.g. a C library with third party dependencies) is the subproject of another project (e.g. a C++ application, using the library). Naming in different contexts The terms superproject/subproject and project/dependency are specific to a given context, but can be used interchangeably. Here is an overview: Context Name for super\u2026 Name for sub\u2026 package manager project/package (source) dependencies multi repo problem superproject subprojects multi repo problem super repository sub repositories multi repo problem superrepo subrepos version control system (VCS) A version control system is a tool to track changes to a set of files and provides auxiliary functional. An very old implementation of a version control system is the revision control system (RCS) . Current popular version control systems are git subversion (svn) mercurial (hg) Concurrent Versions System (cvs) Other names for version control system are source control management (SCM) (used on the git website ) source code control system (SCCS) source code management A non exhaustive list of non so popular version control systems is darcs Jujutsu GNU bazaar [discontinued] Pijul perforce fossil application-level package manager (APM) The term application-level package managers (APM) describes package managers that are integrated into the ecosystem of a programming language. Examples: yarn for Javascript cargo for rust pip for python conan for C++ See also the Wikipedia entry Application-level package managers . These APMs are in contrast to package managers of Linux distributions, like rpm and dpkg, and embedded build systems, like buildroot and Yocto. patch and patch file A patch or patch file is a textual representation of a source code modification. It consists of a patch message describing the change and a diff of the changed code lines. When using git, you can create a patch file with the command git format-patch from a commit object. For example: $ git format-patch e311aaded0a49dced437f2f4be0d2fce4c698132 -1 0001-website-fix-warning-in-mkdocs-serve.patch $ cat 0001-website-fix-warning-in-mkdocs-serve.patch From e311aaded0a49dced437f2f4be0d2fce4c698132 Mon Sep 17 00:00:00 2001 From: Stefan Lengfeld <stefan@lengfeld.xyz> Date: Fri, 7 Feb 2025 23:10:18 +0100 Subject: [PATCH] website: fix warning in 'mkdocs serve' --- website/ref/fosdem25.md | 2 +- 1 file changed, 1 insertion(+), 1 deletion(-) diff --git a/website/ref/fosdem25.md b/website/ref/fosdem25.md index 5dae49e..dca35b8 100644 --- a/website/ref/fosdem25.md +++ b/website/ref/fosdem25.md @@ -26,6 +26,6 @@ Thanks! Content: 1. Present call to action -2. Present [homepage of subpatch](/) +2. Present [homepage of subpatch](../index.md) 3. (Maybe) Do a showcase 4. Repeat call to action :-) -- 2.43.0 Patches are a very old concept of distributed software development. Developers used them even before SCM tools like cvs, svn, and git existed. For some software projects, e.g. the Linux kernel , patch files sent to a mailing list are an integral part of the development model even today. vendoring TODO Explain","title":"Glossary"},{"location":"ref/glossary/#glossary","text":"This page contains explanations of the terms in the context subpatch. The terms are not sorted alphabetically. They are sorted according to relevance. More important terms are at the top, less important terms are at the bottom.","title":"Glossary"},{"location":"ref/glossary/#multi-repository-managementsetupproblem","text":"The multi repository problem is when your project consists of multiple repositories and there are interdependencies between these repositories. E.g. when you must checkout multiple repos, because your build spans across multiple On this website the problem is sometimes called multi repository setup . The process of handling such a project is called multi repository management .","title":"multi repository management/setup/problem"},{"location":"ref/glossary/#superproject","text":"The superproject is the parent project in a multi repository setup. It's often a git repository itself, e.g. for git submodule . When using subpatch the superproject has the configuration file .subpatch at its top level directory.","title":"superproject"},{"location":"ref/glossary/#subprojects","text":"The subproject or subprojects are the external projects, often called (third party) dependencies, that are added to the superproject. Note : The terms super- and sub- projects are always relative to a specific project setup. It might be the case that the superproject of a project (e.g. a C library with third party dependencies) is the subproject of another project (e.g. a C++ application, using the library).","title":"subproject(s)"},{"location":"ref/glossary/#naming-in-different-contexts","text":"The terms superproject/subproject and project/dependency are specific to a given context, but can be used interchangeably. Here is an overview: Context Name for super\u2026 Name for sub\u2026 package manager project/package (source) dependencies multi repo problem superproject subprojects multi repo problem super repository sub repositories multi repo problem superrepo subrepos","title":"Naming in different contexts"},{"location":"ref/glossary/#version-control-system-vcs","text":"A version control system is a tool to track changes to a set of files and provides auxiliary functional. An very old implementation of a version control system is the revision control system (RCS) . Current popular version control systems are git subversion (svn) mercurial (hg) Concurrent Versions System (cvs) Other names for version control system are source control management (SCM) (used on the git website ) source code control system (SCCS) source code management A non exhaustive list of non so popular version control systems is darcs Jujutsu GNU bazaar [discontinued] Pijul perforce fossil","title":"version control system (VCS)"},{"location":"ref/glossary/#application-level-package-manager-apm","text":"The term application-level package managers (APM) describes package managers that are integrated into the ecosystem of a programming language. Examples: yarn for Javascript cargo for rust pip for python conan for C++ See also the Wikipedia entry Application-level package managers . These APMs are in contrast to package managers of Linux distributions, like rpm and dpkg, and embedded build systems, like buildroot and Yocto.","title":"application-level package manager (APM)"},{"location":"ref/glossary/#patch-and-patch-file","text":"A patch or patch file is a textual representation of a source code modification. It consists of a patch message describing the change and a diff of the changed code lines. When using git, you can create a patch file with the command git format-patch from a commit object. For example: $ git format-patch e311aaded0a49dced437f2f4be0d2fce4c698132 -1 0001-website-fix-warning-in-mkdocs-serve.patch $ cat 0001-website-fix-warning-in-mkdocs-serve.patch From e311aaded0a49dced437f2f4be0d2fce4c698132 Mon Sep 17 00:00:00 2001 From: Stefan Lengfeld <stefan@lengfeld.xyz> Date: Fri, 7 Feb 2025 23:10:18 +0100 Subject: [PATCH] website: fix warning in 'mkdocs serve' --- website/ref/fosdem25.md | 2 +- 1 file changed, 1 insertion(+), 1 deletion(-) diff --git a/website/ref/fosdem25.md b/website/ref/fosdem25.md index 5dae49e..dca35b8 100644 --- a/website/ref/fosdem25.md +++ b/website/ref/fosdem25.md @@ -26,6 +26,6 @@ Thanks! Content: 1. Present call to action -2. Present [homepage of subpatch](/) +2. Present [homepage of subpatch](../index.md) 3. (Maybe) Do a showcase 4. Repeat call to action :-) -- 2.43.0 Patches are a very old concept of distributed software development. Developers used them even before SCM tools like cvs, svn, and git existed. For some software projects, e.g. the Linux kernel , patch files sent to a mailing list are an integral part of the development model even today.","title":"patch and patch file"},{"location":"ref/glossary/#vendoring","text":"TODO Explain","title":"vendoring"},{"location":"ref/releases/","text":"Releases This page lists all subpatch release with the release notes. The order is: newest/latest releases are at the top, oldest releases are at the bottom. To install subpatch, follow the steps in the installation tutorial . You always can download the latest standalone python script at the URL: https://subpatch.net/downloads/latest/subpatch Warning : subpatch is in a very very early stage. Do not use it in production environments! E.g. the config format will change. Nevertheless please try it out. Any feedback is welcome. v0.1a6 Fifth release of subpatch. Add output for commands pop and push Add instruction output for using git after commands apply , pop and push Adding git diff --staged --shortstat to every command Fix bug in pop Some internal refactorings Further links: github release page standalone python script for download: https://subpatch.net/downloads/v0.1a5/subpatch Date: 2025-08-13 v0.1a5 Forth release of subpatch. Add command configure Add commands apply , pop and push for patch management And a lot of other changes Further links: github release page standalone python script for download: https://subpatch.net/downloads/v0.1a5/subpatch Date: 2025-08-04 v0.1a4 Third release of subpatch. Changes to the tool Add command update Add command help Implement --depth=1 download optimization for subprojects using git Fix some bugs Rework status and list command Relicense as GPL-2.0-only to make it 1to1 compatible with the git and the Linux kernel source code Store revision argument in subproject metadata Changes to the website A lot of stuff. Further links: github release page standalone python script for download: https://subpatch.net/downloads/v0.1a4/subpatch Date: 2025-01-26 v0.1a3 Second release of subpatch. Changes to the tool Adding support for the command line argument -r | --revision to the add command. This allows to checkout a specific branch, tag or commit or tag id for the subproject. Fix the limitation that only one subproject can be added to the superproject. Now the tool really starts to become usable to management multiple subprojects. Changes to the website Adding a quick start guide to the front page of the webpage Adding a learnings page to explain the path to subpatch and the history from previous attempts and projects Adding a reference for the commandline arguments Merging the website into the main git repository. This makes it easier to work on subpatch. The old subpatch-website repo is archived now. Further links: github release page standalone python script for download: https://subpatch.net/downloads/v0.1a3/subpatch Date: 2024-10-10 v0.1a2 First release of subpatch. For now it supports only two commands: add and status with a very limited amount of functionality. Further links: github release page standalone python script for download: https://subpatch.net/downloads/v0.1a2/subpatch Date: 2024-08-26","title":"Releases"},{"location":"ref/releases/#releases","text":"This page lists all subpatch release with the release notes. The order is: newest/latest releases are at the top, oldest releases are at the bottom. To install subpatch, follow the steps in the installation tutorial . You always can download the latest standalone python script at the URL: https://subpatch.net/downloads/latest/subpatch Warning : subpatch is in a very very early stage. Do not use it in production environments! E.g. the config format will change. Nevertheless please try it out. Any feedback is welcome.","title":"Releases"},{"location":"ref/releases/#v01a6","text":"Fifth release of subpatch. Add output for commands pop and push Add instruction output for using git after commands apply , pop and push Adding git diff --staged --shortstat to every command Fix bug in pop Some internal refactorings Further links: github release page standalone python script for download: https://subpatch.net/downloads/v0.1a5/subpatch Date: 2025-08-13","title":"v0.1a6"},{"location":"ref/releases/#v01a5","text":"Forth release of subpatch. Add command configure Add commands apply , pop and push for patch management And a lot of other changes Further links: github release page standalone python script for download: https://subpatch.net/downloads/v0.1a5/subpatch Date: 2025-08-04","title":"v0.1a5"},{"location":"ref/releases/#v01a4","text":"Third release of subpatch. Changes to the tool Add command update Add command help Implement --depth=1 download optimization for subprojects using git Fix some bugs Rework status and list command Relicense as GPL-2.0-only to make it 1to1 compatible with the git and the Linux kernel source code Store revision argument in subproject metadata Changes to the website A lot of stuff. Further links: github release page standalone python script for download: https://subpatch.net/downloads/v0.1a4/subpatch Date: 2025-01-26","title":"v0.1a4"},{"location":"ref/releases/#v01a3","text":"Second release of subpatch. Changes to the tool Adding support for the command line argument -r | --revision to the add command. This allows to checkout a specific branch, tag or commit or tag id for the subproject. Fix the limitation that only one subproject can be added to the superproject. Now the tool really starts to become usable to management multiple subprojects. Changes to the website Adding a quick start guide to the front page of the webpage Adding a learnings page to explain the path to subpatch and the history from previous attempts and projects Adding a reference for the commandline arguments Merging the website into the main git repository. This makes it easier to work on subpatch. The old subpatch-website repo is archived now. Further links: github release page standalone python script for download: https://subpatch.net/downloads/v0.1a3/subpatch Date: 2024-10-10","title":"v0.1a3"},{"location":"ref/releases/#v01a2","text":"First release of subpatch. For now it supports only two commands: add and status with a very limited amount of functionality. Further links: github release page standalone python script for download: https://subpatch.net/downloads/v0.1a2/subpatch Date: 2024-08-26","title":"v0.1a2"},{"location":"tut/applying-patches/","text":"Applying patches TODO write this tutorial!","title":"Applying patches"},{"location":"tut/applying-patches/#applying-patches","text":"TODO write this tutorial!","title":"Applying patches"},{"location":"tut/basic-usage/","text":"Basic usage This tutorial explains how to add a third party dependency to a git repository. You will learn how to add a subproject to the superproject, how to query the subprojects and get more information about them and how to upgrade a subproject to a new upstream version. In this tutorial the superproject is a simple C-library project that contains a single function that adds two numbers. The subproject (=third party dependency) is the GoogleTest test library for C and C++ projects. Prerequisites To follow the tutorial you need the following setup and skills: Basic knowledge of git and the command line git installed subpatch installed (See Installation for the details) (optional) cmake and a c/c++ compiler installed Cloning the example repository First you need to clone the example repository . It's the superproject that contains minimal C library. On the command line execute $ git clone https://github.com/subpatch/tutorial-basic-usage $ cd tutorial-basic-usage If interested, have a look at the README.md file. (optional) Building the C project If you want, you can also build the C library and test the example program. You need cmake and a c/c++ compiler for that. Execute the commands $ cmake -B build . $ cmake --build build $ build/prog 9 7 16 Adding the third party dependency The example project contains the file test.cc . It is currently unused, because the GoogleTest dependency is missing. You will add it shortly. As a good practice you should add all third party dependencies in a subfolder called external . To add the dependency execute the commands $ mkdir external $ cd external $ subpatch add https://github.com/google/googletest -r v1.15.2 The last command takes some seconds to execute. It downloads the git repository and extract the files. It uses revision v1.15.2 of the git repository. It's a git tag that points to the current latest release of GoogleTest. When the command finishes it prints the message Adding subproject 'googletest' from URL 'https://github.com/google/googletest' at revision 'v1.15.2'... Done. - To inspect the changes, use `git status` and `git diff --staged`. - If you want to keep the changes, commit them with `git commit`. - If you want to revert the changes, execute `git reset --merge`. The message contains three different options. To see what subpatch added to the git index, execute $ git status There are around 240 new files. Commit them by executing $ cd .. $ git commit -m \"external: add gtest\" You have added your first subproject. To see all subprojects execute $ subpatch list external/googletest For now there is only a single subproject. To see more details about the subprojects use the status command. $ subpatch status NOTE: The format of the output is human-readable and unstable. Do not use in scripts! NOTE: The format is markdown currently. Will mostly change in the future. # subproject at 'external/googletest' * was integrated from URL: https://github.com/google/googletest * has integrated revision: v1.17.0 * has integrated object id: 52eb8108c5bdec04579160ae17225d66034bd723 (optional) Enable and build the tests After adding the GoogleTest dependency, you can build and execute the tests. Open the CMakeLists.txt file and add the following lines at the end: # Tests add_subdirectory(external/googletest gtest) add_executable(test test.cc) target_link_libraries(test GTest::gtest_main add) include(GoogleTest) gtest_discover_tests(test) After that you can build and run the tests with $ cmake --build build $ build/test Executing the last command will perform all tests and show the test results. All tests should pass! Don't forget to commit the changes to the CMakeLists.txt : $ git add CMakeLists.txt $ git commit -m \"enable tests\" Updating the subproject There is a new version of GoogleTest available already. See the releases page on github . So update the subproject to a new version. $ subpatch update external/googletest -r v1.17.0 This will print the output Updating subproject 'external/googletest' from URL 'https://github.com/google/googletest' to revision 'v1.17.0'... Done. - To inspect the changes, use `git status` and `git diff --staged`. - If you want to keep the changes, commit them with `git commit`. - If you want to revert the changes, execute `git reset --merge`. (optional) Retest after update After the update of a dependency you should retest your project. For this tutorial it's optional, but it's not optional for a real world project. Execute the tests with $ cmake --build build $ build/test Finish the update After the update all tests are still o.k. Since you are confident of the version upgrade now, commit the changes with $ git commit -m \"external: update gtest\" After commit subpatch status prints the new information: $ subpatch status NOTE: The format of the output is human-readable and unstable. Do not use in scripts! NOTE: The format is markdown currently. Will mostly change in the future. # subproject at 'external/googletest' * was integrated from URL: https://github.com/google/googletest * has integrated revision: v1.17.0 * has integrated object id: 52eb8108c5bdec04579160ae17225d66034bd723 Conclusion Congratulations! You have added your first subproject to a superproject with subpatch add , queried information with subpatch list and subpatch status and updated the subproject to a new upstream version with subpatch update . Now you are ready to continue with the next tutorial Applying patches .","title":"Basic usage"},{"location":"tut/basic-usage/#basic-usage","text":"This tutorial explains how to add a third party dependency to a git repository. You will learn how to add a subproject to the superproject, how to query the subprojects and get more information about them and how to upgrade a subproject to a new upstream version. In this tutorial the superproject is a simple C-library project that contains a single function that adds two numbers. The subproject (=third party dependency) is the GoogleTest test library for C and C++ projects.","title":"Basic usage"},{"location":"tut/basic-usage/#prerequisites","text":"To follow the tutorial you need the following setup and skills: Basic knowledge of git and the command line git installed subpatch installed (See Installation for the details) (optional) cmake and a c/c++ compiler installed","title":"Prerequisites"},{"location":"tut/basic-usage/#cloning-the-example-repository","text":"First you need to clone the example repository . It's the superproject that contains minimal C library. On the command line execute $ git clone https://github.com/subpatch/tutorial-basic-usage $ cd tutorial-basic-usage If interested, have a look at the README.md file.","title":"Cloning the example repository"},{"location":"tut/basic-usage/#optional-building-the-c-project","text":"If you want, you can also build the C library and test the example program. You need cmake and a c/c++ compiler for that. Execute the commands $ cmake -B build . $ cmake --build build $ build/prog 9 7 16","title":"(optional) Building the C project"},{"location":"tut/basic-usage/#adding-the-third-party-dependency","text":"The example project contains the file test.cc . It is currently unused, because the GoogleTest dependency is missing. You will add it shortly. As a good practice you should add all third party dependencies in a subfolder called external . To add the dependency execute the commands $ mkdir external $ cd external $ subpatch add https://github.com/google/googletest -r v1.15.2 The last command takes some seconds to execute. It downloads the git repository and extract the files. It uses revision v1.15.2 of the git repository. It's a git tag that points to the current latest release of GoogleTest. When the command finishes it prints the message Adding subproject 'googletest' from URL 'https://github.com/google/googletest' at revision 'v1.15.2'... Done. - To inspect the changes, use `git status` and `git diff --staged`. - If you want to keep the changes, commit them with `git commit`. - If you want to revert the changes, execute `git reset --merge`. The message contains three different options. To see what subpatch added to the git index, execute $ git status There are around 240 new files. Commit them by executing $ cd .. $ git commit -m \"external: add gtest\" You have added your first subproject. To see all subprojects execute $ subpatch list external/googletest For now there is only a single subproject. To see more details about the subprojects use the status command. $ subpatch status NOTE: The format of the output is human-readable and unstable. Do not use in scripts! NOTE: The format is markdown currently. Will mostly change in the future. # subproject at 'external/googletest' * was integrated from URL: https://github.com/google/googletest * has integrated revision: v1.17.0 * has integrated object id: 52eb8108c5bdec04579160ae17225d66034bd723","title":"Adding the third party dependency"},{"location":"tut/basic-usage/#optional-enable-and-build-the-tests","text":"After adding the GoogleTest dependency, you can build and execute the tests. Open the CMakeLists.txt file and add the following lines at the end: # Tests add_subdirectory(external/googletest gtest) add_executable(test test.cc) target_link_libraries(test GTest::gtest_main add) include(GoogleTest) gtest_discover_tests(test) After that you can build and run the tests with $ cmake --build build $ build/test Executing the last command will perform all tests and show the test results. All tests should pass! Don't forget to commit the changes to the CMakeLists.txt : $ git add CMakeLists.txt $ git commit -m \"enable tests\"","title":"(optional) Enable and build the tests"},{"location":"tut/basic-usage/#updating-the-subproject","text":"There is a new version of GoogleTest available already. See the releases page on github . So update the subproject to a new version. $ subpatch update external/googletest -r v1.17.0 This will print the output Updating subproject 'external/googletest' from URL 'https://github.com/google/googletest' to revision 'v1.17.0'... Done. - To inspect the changes, use `git status` and `git diff --staged`. - If you want to keep the changes, commit them with `git commit`. - If you want to revert the changes, execute `git reset --merge`.","title":"Updating the subproject"},{"location":"tut/basic-usage/#optional-retest-after-update","text":"After the update of a dependency you should retest your project. For this tutorial it's optional, but it's not optional for a real world project. Execute the tests with $ cmake --build build $ build/test","title":"(optional) Retest after update"},{"location":"tut/basic-usage/#finish-the-update","text":"After the update all tests are still o.k. Since you are confident of the version upgrade now, commit the changes with $ git commit -m \"external: update gtest\" After commit subpatch status prints the new information: $ subpatch status NOTE: The format of the output is human-readable and unstable. Do not use in scripts! NOTE: The format is markdown currently. Will mostly change in the future. # subproject at 'external/googletest' * was integrated from URL: https://github.com/google/googletest * has integrated revision: v1.17.0 * has integrated object id: 52eb8108c5bdec04579160ae17225d66034bd723","title":"Finish the update"},{"location":"tut/basic-usage/#conclusion","text":"Congratulations! You have added your first subproject to a superproject with subpatch add , queried information with subpatch list and subpatch status and updated the subproject to a new upstream version with subpatch update . Now you are ready to continue with the next tutorial Applying patches .","title":"Conclusion"},{"location":"tut/installation/","text":"Installation This tutorial explains who to install subpatch on your computer. You will learn how to install subpatch either with pipx into your HOME directory or as a standalone script into the PATH. Warning : subpatch is in a very very early stage. Do not use it in production environments! E.g. the config format will change. Nevertheless please try it out. Any feedback is welcome. Prerequisites To follow this tutorial you need a PC or notebook with a Linux Operating System installed. This tutorial will assume Ubuntu , but any current distribution should work. Also MacOS may work out of the box, but it's not tested for now. With pipx into your HOME directory The subpatch project is released on PyPI , the \"Python Package Index\". The PyPI's subpatch site contains the project specific informations. Install pipx To install subpatch, you can use pipx . pipx is a tool to manage python virtual environments in your HOME directory. To install pipx on Ubuntu, execute $ sudo apt install pipx Note : For other distributions use the distro specific package manager. To check if pipx works, you can execute the list command. An example: $ pipx list nothing has been installed with pipx \ud83d\ude34 Install subpatch with pipx If everything is fine, you can install the latest version of subpatch with the command $ pipx install subpatch The output of the command should look like installed package subpatch 0.1a2, installed using Python 3.10.12 These apps are now globally available - subpatch done! \u2728 \ud83c\udf1f \u2728 If some of the numbers are different, that's o.k. To test that subpatch works, you can execute the command $ subpatch --version It should print the version number of subpatch that is currently installed. Congratulations , now you successfully installed subpatch. A final note: To get further infos and the help text, execute $ subpatch --help As a standalone script into the PATH You can also install subpatch as a standalone python script into your PATH. Create a bin folder First make sure that you have a directory that is listed in your PATH. If you have another folder in the PATH for other scripts already, you can skip this step. I used a bin directory in the HOME folder for that. To create it, execute $ mkdir ~/bin Then this folder must be added to the environment variable PATH. This can be done with $ echo 'export PATH=$PATH:$HOME/bin' >> ~/.bashrc It adds a line at the end of the ~./bashrc file. The change will only be active in new shells that are spawned now. So start a new shell with $ bash Note : This tutorial assumes that you are using bash. If you use another shell, like zsh or fish, you mostly already know everything in the tutorial and can adapt it yourself :-) To check that the modifications of the PATH variable worked, execute $ echo $PATH It prints all folders that are scanned for executable files. The list should contain the bin folder in your HOME directory at the end. Download and install subpatch The last step is to download the subpatch script and copy it into the bin folder. First go to the releases page and find the latest release. There are two options: manual download or using the command line: Manual download Now click on the link for standalone python script and download the script with your browser. After you downloaded the standalone script into your download directory, you must move it to the bin directory. For example: $ mv subpatch ~/bin/ The executable bit is not set for downloaded files. You must manually set it with the command $ chmod +x ~/bin/subpatch Otherwise the shell cannot execute the script. Using the command line Apart from the manual download, you can use command line tools. To download the script and set the executable bit, just execute: $ wget https://github.com/lengfeld/subpatch/releases/download/v0.1a2/subpatch -O ~/bin/subpatch $ chmod +x ~/bin/subpatch The above command is just an example. For other versions of subpatch, the version number in the URL looks different. Test subpatch After download and installation you should test the subpatch command line tool. To test that it works, you can execute the command $ subpatch --version It should print the version number of subpatch that is currently installed. Congratulations , now you successfully installed subpatch. A final note: To get further infos and the help text, execute $ subpatch --help Conclusion You have learned two different methods to install subpatch and how to query the version information and help text. Now you are ready to continue with the next tutorial Basic Usage .","title":"Installation"},{"location":"tut/installation/#installation","text":"This tutorial explains who to install subpatch on your computer. You will learn how to install subpatch either with pipx into your HOME directory or as a standalone script into the PATH. Warning : subpatch is in a very very early stage. Do not use it in production environments! E.g. the config format will change. Nevertheless please try it out. Any feedback is welcome.","title":"Installation"},{"location":"tut/installation/#prerequisites","text":"To follow this tutorial you need a PC or notebook with a Linux Operating System installed. This tutorial will assume Ubuntu , but any current distribution should work. Also MacOS may work out of the box, but it's not tested for now.","title":"Prerequisites"},{"location":"tut/installation/#with-pipx-into-your-home-directory","text":"The subpatch project is released on PyPI , the \"Python Package Index\". The PyPI's subpatch site contains the project specific informations.","title":"With pipx into your HOME directory"},{"location":"tut/installation/#install-pipx","text":"To install subpatch, you can use pipx . pipx is a tool to manage python virtual environments in your HOME directory. To install pipx on Ubuntu, execute $ sudo apt install pipx Note : For other distributions use the distro specific package manager. To check if pipx works, you can execute the list command. An example: $ pipx list nothing has been installed with pipx \ud83d\ude34","title":"Install pipx"},{"location":"tut/installation/#install-subpatch-with-pipx","text":"If everything is fine, you can install the latest version of subpatch with the command $ pipx install subpatch The output of the command should look like installed package subpatch 0.1a2, installed using Python 3.10.12 These apps are now globally available - subpatch done! \u2728 \ud83c\udf1f \u2728 If some of the numbers are different, that's o.k. To test that subpatch works, you can execute the command $ subpatch --version It should print the version number of subpatch that is currently installed. Congratulations , now you successfully installed subpatch. A final note: To get further infos and the help text, execute $ subpatch --help","title":"Install subpatch with pipx"},{"location":"tut/installation/#as-a-standalone-script-into-the-path","text":"You can also install subpatch as a standalone python script into your PATH.","title":"As a standalone script into the PATH"},{"location":"tut/installation/#create-a-bin-folder","text":"First make sure that you have a directory that is listed in your PATH. If you have another folder in the PATH for other scripts already, you can skip this step. I used a bin directory in the HOME folder for that. To create it, execute $ mkdir ~/bin Then this folder must be added to the environment variable PATH. This can be done with $ echo 'export PATH=$PATH:$HOME/bin' >> ~/.bashrc It adds a line at the end of the ~./bashrc file. The change will only be active in new shells that are spawned now. So start a new shell with $ bash Note : This tutorial assumes that you are using bash. If you use another shell, like zsh or fish, you mostly already know everything in the tutorial and can adapt it yourself :-) To check that the modifications of the PATH variable worked, execute $ echo $PATH It prints all folders that are scanned for executable files. The list should contain the bin folder in your HOME directory at the end.","title":"Create a bin folder"},{"location":"tut/installation/#download-and-install-subpatch","text":"The last step is to download the subpatch script and copy it into the bin folder. First go to the releases page and find the latest release. There are two options: manual download or using the command line:","title":"Download and install subpatch"},{"location":"tut/installation/#manual-download","text":"Now click on the link for standalone python script and download the script with your browser. After you downloaded the standalone script into your download directory, you must move it to the bin directory. For example: $ mv subpatch ~/bin/ The executable bit is not set for downloaded files. You must manually set it with the command $ chmod +x ~/bin/subpatch Otherwise the shell cannot execute the script.","title":"Manual download"},{"location":"tut/installation/#using-the-command-line","text":"Apart from the manual download, you can use command line tools. To download the script and set the executable bit, just execute: $ wget https://github.com/lengfeld/subpatch/releases/download/v0.1a2/subpatch -O ~/bin/subpatch $ chmod +x ~/bin/subpatch The above command is just an example. For other versions of subpatch, the version number in the URL looks different.","title":"Using the command line"},{"location":"tut/installation/#test-subpatch","text":"After download and installation you should test the subpatch command line tool. To test that it works, you can execute the command $ subpatch --version It should print the version number of subpatch that is currently installed. Congratulations , now you successfully installed subpatch. A final note: To get further infos and the help text, execute $ subpatch --help","title":"Test subpatch"},{"location":"tut/installation/#conclusion","text":"You have learned two different methods to install subpatch and how to query the version information and help text. Now you are ready to continue with the next tutorial Basic Usage .","title":"Conclusion"}]}