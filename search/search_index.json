{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"subpatch: fearless multi-repository management - stay relaxed! Welcome to the website of subpatch. The tool that does multi-repository management right. Don't worry, stay relaxed! Currently this project is just an idea. No code yet. But the general concept is already proven and works! The subpatch project will provide two things: A command line tool called subpatch to manage subprojects in a source control repository, e.g. in a git repository. The github repository is subpatch . Documentation, explanations and opinions about multi repo setups and management. This is this website. If you are currently using git-submodules or repo and you are frustrated, subpatch will be mostly your solution! If you are interested, email me . subpatch usecases subpatch is interesting for you if you want to do the following tasks: assemble a monorepo from multiple repositories integrate third party dependencies into your project as source files maintain a local fork (=linear patchstack) of a third party dependency subpatch's concept subpatch will be a subprojects management tool based on the following ideas: It's based on the idea of git add and git read-tree . The files of subprojects are added as normal files to the superproject. In most cases this will be just a git repository. The metadata of a subproject is saved in a git-config styled configuration file. Modifications of the subproject are possible and subpatch helps to maintain a linear patch stack of the modifications. Importing new versions of the subproject is possible and subpatch helps to rebase the local modifications. subpatch main difference When you use subpatch the subprojects are not git repository itself. The files of the subprojects are added as files to the superproject. You will only have to deal with a single git repository. This is in contrast to other tools, e.g. git-submodules repo kas west These tools manage multi git repository management and try to combine them into a big superproject.","title":"Home"},{"location":"#subpatch-fearless-multi-repository-management-stay-relaxed","text":"Welcome to the website of subpatch. The tool that does multi-repository management right. Don't worry, stay relaxed! Currently this project is just an idea. No code yet. But the general concept is already proven and works! The subpatch project will provide two things: A command line tool called subpatch to manage subprojects in a source control repository, e.g. in a git repository. The github repository is subpatch . Documentation, explanations and opinions about multi repo setups and management. This is this website. If you are currently using git-submodules or repo and you are frustrated, subpatch will be mostly your solution! If you are interested, email me .","title":"subpatch: fearless multi-repository management - stay relaxed!"},{"location":"#subpatch-usecases","text":"subpatch is interesting for you if you want to do the following tasks: assemble a monorepo from multiple repositories integrate third party dependencies into your project as source files maintain a local fork (=linear patchstack) of a third party dependency","title":"subpatch usecases"},{"location":"#subpatchs-concept","text":"subpatch will be a subprojects management tool based on the following ideas: It's based on the idea of git add and git read-tree . The files of subprojects are added as normal files to the superproject. In most cases this will be just a git repository. The metadata of a subproject is saved in a git-config styled configuration file. Modifications of the subproject are possible and subpatch helps to maintain a linear patch stack of the modifications. Importing new versions of the subproject is possible and subpatch helps to rebase the local modifications.","title":"subpatch's concept"},{"location":"#subpatch-main-difference","text":"When you use subpatch the subprojects are not git repository itself. The files of the subprojects are added as files to the superproject. You will only have to deal with a single git repository. This is in contrast to other tools, e.g. git-submodules repo kas west These tools manage multi git repository management and try to combine them into a big superproject.","title":"subpatch main difference"},{"location":"imprint/","text":"Imprint This website is created and maintained by name: Stefan Lengfeld address: Germany, 53721 Siegburg e-mail: stefan+subpatch@lengfeld.xyz The website's source is available in the folder website/ in the subpatch repository .","title":"Imprint"},{"location":"imprint/#imprint","text":"This website is created and maintained by name: Stefan Lengfeld address: Germany, 53721 Siegburg e-mail: stefan+subpatch@lengfeld.xyz The website's source is available in the folder website/ in the subpatch repository .","title":"Imprint"},{"location":"exp/comparison/","text":"Comparison to other tools Subpatch is not the first tool that tries to solve the multi repository problem. Other tools are git-submodules repo kas west git-subtree This page will compare these tools with subpatch. Technical comparison The following table compares the architecture of the tools subpatch repo git submodule west kas subtree config format git-cfg xml git-cfg yaml yaml none superproject any(1) none git git git git subprojects any(1) git git git git git language python python C python python shell Explanations of the rows: config format : The format of the config file that is used to track the information about the subprojects. For repo and west the file is called the manifest file. superproject : The type of cvs that is the top level repository and also (often) tracks the configuration of subprojects. (2) subprojects : The type of cvs that is support as a subproject. For all other tools, except subpatch, only other git repositories are supported. language : The main programming language that the tool is written in. Legend: git-cfg stands for the git config format used in .git/config , ~/.gitconfig and .gitmodules . (1): subpatch does not support all other cvs as super- and subprojects for now. Still work in progress. (2): The repo tool is special here. It tracks the subprojects in a manifest file in a separate git repository, the so called manifest repository . But this repository is not part of the directory hierarchy when the project is checked out. It does not sit at the top level of the superproject. Other multi repository management tools Apart from the above already mentioned tools there exits a long list of other attempts to solve the multi repository problem. The following list should list all the other tools I have found so far: Git X-Modules GitSlave Combo-layer If you know additional tools, please post a pull request or email me.","title":"Comparison to other tools"},{"location":"exp/comparison/#comparison-to-other-tools","text":"Subpatch is not the first tool that tries to solve the multi repository problem. Other tools are git-submodules repo kas west git-subtree This page will compare these tools with subpatch.","title":"Comparison to other tools"},{"location":"exp/comparison/#technical-comparison","text":"The following table compares the architecture of the tools subpatch repo git submodule west kas subtree config format git-cfg xml git-cfg yaml yaml none superproject any(1) none git git git git subprojects any(1) git git git git git language python python C python python shell Explanations of the rows: config format : The format of the config file that is used to track the information about the subprojects. For repo and west the file is called the manifest file. superproject : The type of cvs that is the top level repository and also (often) tracks the configuration of subprojects. (2) subprojects : The type of cvs that is support as a subproject. For all other tools, except subpatch, only other git repositories are supported. language : The main programming language that the tool is written in. Legend: git-cfg stands for the git config format used in .git/config , ~/.gitconfig and .gitmodules . (1): subpatch does not support all other cvs as super- and subprojects for now. Still work in progress. (2): The repo tool is special here. It tracks the subprojects in a manifest file in a separate git repository, the so called manifest repository . But this repository is not part of the directory hierarchy when the project is checked out. It does not sit at the top level of the superproject.","title":"Technical comparison"},{"location":"exp/comparison/#other-multi-repository-management-tools","text":"Apart from the above already mentioned tools there exits a long list of other attempts to solve the multi repository problem. The following list should list all the other tools I have found so far: Git X-Modules GitSlave Combo-layer If you know additional tools, please post a pull request or email me.","title":"Other multi repository management tools"},{"location":"exp/design/","text":"subpatch design subpatch is based on my experiences and learnings as a (embedded) software engineer. Everything that I have seen and done in the last ten years feeds into the following list of requirements. See the history page for details. NOTE : For now the implementation of subpatch not complete. Please read the requirement list as a vision for the first major release of subpatch, not as a status of the implementation. Requirements The tool \u2026 ( R1 ) should support git, cvs, mercurial, subversion and non-cvs environment as superprojects. ( R2 ) do not interfere with the vcs. The existing workflows like checking out, cloning, switching branches, updating, rebasing, tagging, forking, bisecting, releasing and ... should stay the same. ( R3 ) should support git, cvs, mercurial, subversion and source code archives (like tarballs or zip files) as source dependencies/subprojects. ( R4 ) should track the original metadata (e.g. url, commit ids, checksums, ... ) of the source dependency to verify the authenticity of the dependency later. ( R5 ) should help integrating updates of the source dependencies. ( R6 ) should support local patching of source dependencies. ( R7 ) If the source dependency is patched locally, it should help maintaining a linear patch stack. ( R8 ) should rebase local patches automatically, when doing an update of a source dependency and there are no conflicts with the local patches. ( R9 ) should help porting the local patches, when doing an update of a source dependency and there are conflicts with the local patches. ( R10 ) should provided an stable command line API (plumbing commands) to support other tools to track source dependencies, e.g. to automatically check for updates or for CVEs. ( R11 ) should support every development platform that also supports git and python, like Linux, unixes, Windows and MacOS. ( R12 ) should scale to the size of the AOSP (Android Open Source Project). Design decisions While developing subpatch, the following design decisions were taken. The requirement list still gives a lot of freedom for the implementation. Therefore the chosen decisions are documented and explained here. ( DD1 ): written in python3 (but open for a port to another language later if successful) [+] faster iteration speed [+] Easier deployment/install for users of subpatch. python runs everywhere. [+] Programming language that I know really good and written a lot of code already. ( DD2 ): config file format is git-config [+] the same config format that the main cvs for subpatch (=git) uses. [+] Most developers are already familiar with the config format, e.g. because they are modyfing ~/.git config . ( DD3 ): The config is a single file and placed at the root of the repository [+] The project's root directory can be found even without scm. E.g. after the source code was exported with git archive . [+] A single file avoids a search in all sub directories. Can be expensive for big projects. NOTE: This list is not completed yet and should grow while supbatch is developed.","title":"subpatch design"},{"location":"exp/design/#subpatch-design","text":"subpatch is based on my experiences and learnings as a (embedded) software engineer. Everything that I have seen and done in the last ten years feeds into the following list of requirements. See the history page for details. NOTE : For now the implementation of subpatch not complete. Please read the requirement list as a vision for the first major release of subpatch, not as a status of the implementation.","title":"subpatch design"},{"location":"exp/design/#requirements","text":"The tool \u2026 ( R1 ) should support git, cvs, mercurial, subversion and non-cvs environment as superprojects. ( R2 ) do not interfere with the vcs. The existing workflows like checking out, cloning, switching branches, updating, rebasing, tagging, forking, bisecting, releasing and ... should stay the same. ( R3 ) should support git, cvs, mercurial, subversion and source code archives (like tarballs or zip files) as source dependencies/subprojects. ( R4 ) should track the original metadata (e.g. url, commit ids, checksums, ... ) of the source dependency to verify the authenticity of the dependency later. ( R5 ) should help integrating updates of the source dependencies. ( R6 ) should support local patching of source dependencies. ( R7 ) If the source dependency is patched locally, it should help maintaining a linear patch stack. ( R8 ) should rebase local patches automatically, when doing an update of a source dependency and there are no conflicts with the local patches. ( R9 ) should help porting the local patches, when doing an update of a source dependency and there are conflicts with the local patches. ( R10 ) should provided an stable command line API (plumbing commands) to support other tools to track source dependencies, e.g. to automatically check for updates or for CVEs. ( R11 ) should support every development platform that also supports git and python, like Linux, unixes, Windows and MacOS. ( R12 ) should scale to the size of the AOSP (Android Open Source Project).","title":"Requirements"},{"location":"exp/design/#design-decisions","text":"While developing subpatch, the following design decisions were taken. The requirement list still gives a lot of freedom for the implementation. Therefore the chosen decisions are documented and explained here. ( DD1 ): written in python3 (but open for a port to another language later if successful) [+] faster iteration speed [+] Easier deployment/install for users of subpatch. python runs everywhere. [+] Programming language that I know really good and written a lot of code already. ( DD2 ): config file format is git-config [+] the same config format that the main cvs for subpatch (=git) uses. [+] Most developers are already familiar with the config format, e.g. because they are modyfing ~/.git config . ( DD3 ): The config is a single file and placed at the root of the repository [+] The project's root directory can be found even without scm. E.g. after the source code was exported with git archive . [+] A single file avoids a search in all sub directories. Can be expensive for big projects. NOTE: This list is not completed yet and should grow while supbatch is developed.","title":"Design decisions"},{"location":"exp/history/","text":"Pre-subpatch history subpatch is not my first attempt to solve the multi repository problem. There is a long history before I started the subpatch project. This page should tell the history and what learnings I made along the way. These learnings lead to the design and the requirements of subpatch. lt;dr: The summary of all learnings is ( L1 ) The solution to the multi repository problem is inside of git (or generally inside any version control system). ( L2 ) Good documentation is very very important. ( L3 ) Good documentation with good tooling is the key. ( L4 ) Use the right design to minimize the inherent complexity to avoid accidental complexity. ( L5 ) The build process must not span multiple of your own repositories. ( L6 ) The only sane way to maintain a downstream fork is a linear patch stack (=series of patches). ( L7 ) Good development practices, like atomic commits, must still be possible with the multi repository management tool. Even across the used subprojects. Personal history While writing these lines it's the year 2024. I started to use Linux in my youth and also started to code at the same time. That is nearly 20 years in the past now. So I may claim that I've been doing software development for 15+ years. In university, around 2011, I started to write software as a research assistant. Since 2014 (ten years) I've been doing embedded software development as my main job and can call myself a professional software developer. In all these years I have already seen a lot of programming languages, projects and problems. Multi repository problem (2015) In 2015 at my first embedded software development job I encountered the multi repository problem. The company was on the way to migrate the embedded build system for their Linux distribution and firmware images to Yocto. Back then I started to learn and use the repo tool by Google to manage projects with multiple repositories. While doing the first releases of the Linux firmware, I noticed the weaknesses of using repo. Everything that is easy with a single repository like checking out branches of a coworker, switching between different development branches (stable vs main), bisecting errors and making a release and tagging becomes a major hassle with multiple repositories and the repo tool. And it's very error prone. At that time I started a new hobby project called rap . The solution is inside a git repo (2015) So I'm working on a better version of the repo, called rap , for three months. It should be repo by Google done right. I wrote it in python and at the end it consists of 2889 lines of code for the program and 985 lines of tests. It should support features, like easy checkout of multiple repos, bisecting across multiple repos and git bundles across multi repos. After the three months I noticed that I was building a version control system for git repositories. And git is itself a version control system. That is duplicate and useless work. This brought me to the first learning: ( L1 ) The solution to the multi repository problem is inside of git (or generally inside any version control system). The solution is not writing a new version control system to manage version control systems. So I abandoned the rap project and looked at existing solutions that allow me to manage multiple repositories inside a git repo. Most people know git submodules , but there is also git subtree . Documentation, documentation and documentation (2015) I already knew git submodules and also knew that has its own set of usability challenges. So I looked at git subtree and its subtree merge strategy . Maybe it's a viable solution. After trying it out I noticed that the documentation is lacking. I started to write additional documentation for it and called the project Handbook of Applied git subtree merge . The problem is explaining the problem to developers and explaining how the tool works to solve the management problem. This can be summarized up in the learning: ( L2 ) Good documentation is very very important. Quickly after that I also noticed that the tooling of git subtree is inadequate. Only additional documentation will not fix usability issues. The third learning is: ( L3 ) Good documentation with good tooling is the key. Better Tooling (2016) In 2016 I started to work on better tooling for git subtree. I called the project git-subtreemerge . It should be git subtree done right. A better tool to perform and help the user to use the subtree merge strategy of git. I worked on this project from June 2016 to May 2017 (roughly eight months) in my spare time. At the end the project consist of 5027 lines of python code for the program and 9544 lines of python code lines are tests. So 65% percent of all the code are tests. At this stage the basic features were working in the tool and I wanted to release it as a prototype. So I started to work on the documentation that explains how the tool works and the theory behind it. I quickly noticed that this would not fly. It's not about the accidental complexity of the git subtree merge strategy or the tool. It's about the essential or inherent complexity of it. The core problem is that the merge strategy is mixing commits of the subproject into the history (the commit graph) of the superproject. If you have multiple subprojects, then you also have multiple different types of subproject commits in the history of the superproject. Combine this with changes to the subproject in the superproject and combine this with merges (different development branches) in the superproject, you get a complexity explosion of everything that can happen and must be explained. In fact there are mathematical underlying properties, embeddings and commutative operations, for this. So in general it's sound. But this setup is not explainable to even experienced git users. At this point I abandoned the project. My main learning was ( L4 ) Use the right design to minimize the inherent complexity to avoid accidental complexity. To phrase it for the git subtree merge strategy. It has a huge inherent complexity, which is way too big for the essential complexity of the multi repository management problem. Gerrit and repo (2018) In 2018 I had the chance to work on a project that uses the Gerrit Code Review System together with the repo tool. I did expect the same problems as in the year 2016, but gave the combination of gerrit plus repo another try. Summary: It's still madness. Even simple things like checking out the branches of a coworker is non-trivial. It's not supported by the repo tool. We started to implement our own tool called repoload for that. At least Gerrit supports submitting/accepting cross atomic commits. That's a feature you need when you start to distribute your project across multiple git repos. The documentation Submitting Changes Across Repositories by using Topics . So Gerrit has the cross repo atomic commit feature. Sadly our continuous integration system (CI), Jenkins in this case, did not. Our project rolled out its own implementation based on the Change-Id and Depends-On fields in the commit messages. Writing in a combination of bash and groovy. Also madness. There were a couple of other learnings from this project which I can summarize up as: ( L5 ) The build process must not span multiple of your own repositories. You can also phrase it differently. When you or your CI system must checkout multiple of your own git repos for building the project, you are doing it wrong. git add and linear patch stacks (2018+) In the same project we used a different solution (not repo or git submodules) for a small component. We integrated a C++ dependency into the git repository with git add . We just added the source files in a single commit into the project. We even applied local patches to the project as normal git commits on top of it. When upgrading the dependency we removed the original files, added the new source files and reapplied the patches with git cherry-pick . That process worked nicely. The learning is: ( L6 ) The only sane way to maintain a downstream fork is a linear patch stack (=series of patches). And that is actually a very old thing. Linux distributions, like the big ones for the desktop but also for embedded devices, maintain a linear patch stack for their packages (=source dependencies). It's a process that has been done for decades now. Conclusion That is my history and how I came up with the design of subpatch. Hopefully it shows that the requirements and design decision are not an ad-hoc idea, but instead based on a long period of experience and tackling the multi repository problem from different angles. One last learning that also feeds into subpatch is ( L7 ) Good development practices, like atomic commits, must still be possible with the multi repository management tool. Even across the used subprojects.","title":"Pre-subpatch history"},{"location":"exp/history/#pre-subpatch-history","text":"subpatch is not my first attempt to solve the multi repository problem. There is a long history before I started the subpatch project. This page should tell the history and what learnings I made along the way. These learnings lead to the design and the requirements of subpatch. lt;dr: The summary of all learnings is ( L1 ) The solution to the multi repository problem is inside of git (or generally inside any version control system). ( L2 ) Good documentation is very very important. ( L3 ) Good documentation with good tooling is the key. ( L4 ) Use the right design to minimize the inherent complexity to avoid accidental complexity. ( L5 ) The build process must not span multiple of your own repositories. ( L6 ) The only sane way to maintain a downstream fork is a linear patch stack (=series of patches). ( L7 ) Good development practices, like atomic commits, must still be possible with the multi repository management tool. Even across the used subprojects.","title":"Pre-subpatch history"},{"location":"exp/history/#personal-history","text":"While writing these lines it's the year 2024. I started to use Linux in my youth and also started to code at the same time. That is nearly 20 years in the past now. So I may claim that I've been doing software development for 15+ years. In university, around 2011, I started to write software as a research assistant. Since 2014 (ten years) I've been doing embedded software development as my main job and can call myself a professional software developer. In all these years I have already seen a lot of programming languages, projects and problems.","title":"Personal history"},{"location":"exp/history/#multi-repository-problem-2015","text":"In 2015 at my first embedded software development job I encountered the multi repository problem. The company was on the way to migrate the embedded build system for their Linux distribution and firmware images to Yocto. Back then I started to learn and use the repo tool by Google to manage projects with multiple repositories. While doing the first releases of the Linux firmware, I noticed the weaknesses of using repo. Everything that is easy with a single repository like checking out branches of a coworker, switching between different development branches (stable vs main), bisecting errors and making a release and tagging becomes a major hassle with multiple repositories and the repo tool. And it's very error prone. At that time I started a new hobby project called rap .","title":"Multi repository problem (2015)"},{"location":"exp/history/#the-solution-is-inside-a-git-repo-2015","text":"So I'm working on a better version of the repo, called rap , for three months. It should be repo by Google done right. I wrote it in python and at the end it consists of 2889 lines of code for the program and 985 lines of tests. It should support features, like easy checkout of multiple repos, bisecting across multiple repos and git bundles across multi repos. After the three months I noticed that I was building a version control system for git repositories. And git is itself a version control system. That is duplicate and useless work. This brought me to the first learning: ( L1 ) The solution to the multi repository problem is inside of git (or generally inside any version control system). The solution is not writing a new version control system to manage version control systems. So I abandoned the rap project and looked at existing solutions that allow me to manage multiple repositories inside a git repo. Most people know git submodules , but there is also git subtree .","title":"The solution is inside a git repo (2015)"},{"location":"exp/history/#documentation-documentation-and-documentation-2015","text":"I already knew git submodules and also knew that has its own set of usability challenges. So I looked at git subtree and its subtree merge strategy . Maybe it's a viable solution. After trying it out I noticed that the documentation is lacking. I started to write additional documentation for it and called the project Handbook of Applied git subtree merge . The problem is explaining the problem to developers and explaining how the tool works to solve the management problem. This can be summarized up in the learning: ( L2 ) Good documentation is very very important. Quickly after that I also noticed that the tooling of git subtree is inadequate. Only additional documentation will not fix usability issues. The third learning is: ( L3 ) Good documentation with good tooling is the key.","title":"Documentation, documentation and documentation (2015)"},{"location":"exp/history/#better-tooling-2016","text":"In 2016 I started to work on better tooling for git subtree. I called the project git-subtreemerge . It should be git subtree done right. A better tool to perform and help the user to use the subtree merge strategy of git. I worked on this project from June 2016 to May 2017 (roughly eight months) in my spare time. At the end the project consist of 5027 lines of python code for the program and 9544 lines of python code lines are tests. So 65% percent of all the code are tests. At this stage the basic features were working in the tool and I wanted to release it as a prototype. So I started to work on the documentation that explains how the tool works and the theory behind it. I quickly noticed that this would not fly. It's not about the accidental complexity of the git subtree merge strategy or the tool. It's about the essential or inherent complexity of it. The core problem is that the merge strategy is mixing commits of the subproject into the history (the commit graph) of the superproject. If you have multiple subprojects, then you also have multiple different types of subproject commits in the history of the superproject. Combine this with changes to the subproject in the superproject and combine this with merges (different development branches) in the superproject, you get a complexity explosion of everything that can happen and must be explained. In fact there are mathematical underlying properties, embeddings and commutative operations, for this. So in general it's sound. But this setup is not explainable to even experienced git users. At this point I abandoned the project. My main learning was ( L4 ) Use the right design to minimize the inherent complexity to avoid accidental complexity. To phrase it for the git subtree merge strategy. It has a huge inherent complexity, which is way too big for the essential complexity of the multi repository management problem.","title":"Better Tooling (2016)"},{"location":"exp/history/#gerrit-and-repo-2018","text":"In 2018 I had the chance to work on a project that uses the Gerrit Code Review System together with the repo tool. I did expect the same problems as in the year 2016, but gave the combination of gerrit plus repo another try. Summary: It's still madness. Even simple things like checking out the branches of a coworker is non-trivial. It's not supported by the repo tool. We started to implement our own tool called repoload for that. At least Gerrit supports submitting/accepting cross atomic commits. That's a feature you need when you start to distribute your project across multiple git repos. The documentation Submitting Changes Across Repositories by using Topics . So Gerrit has the cross repo atomic commit feature. Sadly our continuous integration system (CI), Jenkins in this case, did not. Our project rolled out its own implementation based on the Change-Id and Depends-On fields in the commit messages. Writing in a combination of bash and groovy. Also madness. There were a couple of other learnings from this project which I can summarize up as: ( L5 ) The build process must not span multiple of your own repositories. You can also phrase it differently. When you or your CI system must checkout multiple of your own git repos for building the project, you are doing it wrong.","title":"Gerrit and repo (2018)"},{"location":"exp/history/#git-add-and-linear-patch-stacks-2018","text":"In the same project we used a different solution (not repo or git submodules) for a small component. We integrated a C++ dependency into the git repository with git add . We just added the source files in a single commit into the project. We even applied local patches to the project as normal git commits on top of it. When upgrading the dependency we removed the original files, added the new source files and reapplied the patches with git cherry-pick . That process worked nicely. The learning is: ( L6 ) The only sane way to maintain a downstream fork is a linear patch stack (=series of patches). And that is actually a very old thing. Linux distributions, like the big ones for the desktop but also for embedded devices, maintain a linear patch stack for their packages (=source dependencies). It's a process that has been done for decades now.","title":"git add and linear patch stacks (2018+)"},{"location":"exp/history/#conclusion","text":"That is my history and how I came up with the design of subpatch. Hopefully it shows that the requirements and design decision are not an ad-hoc idea, but instead based on a long period of experience and tackling the multi repository problem from different angles. One last learning that also feeds into subpatch is ( L7 ) Good development practices, like atomic commits, must still be possible with the multi repository management tool. Even across the used subprojects.","title":"Conclusion"},{"location":"exp/intro/","text":"Introduction Welcome to the realm of multi-repository management and third-party source dependencies. Even if you are an experienced software developer, you may not have encountered this issue in your career already. It only arises when working on larger software projects, managing inter-team software dependencies, or in the field of embedded software engineering. This page explains the issue with two examples: Example 1: C/C++ library as source dependency Example 2: multi repository project for linux embedded firmware Example 1: C/C++ library as source dependency This example illustrates a third party source dependency. I maintain a small C/C++ library called aminilog . It's useful when writing C/C++ code in an Android Application project that uses the Android NDK (Native Development toolkit). The library provides ready to use logging macros, because the NDK only contains the low level APIs for logging. I publish the library as a plain git repository. Since it is really simple, there are no release tarballs or tags and no binary artifacts. Also binary artifacts would do not make sense, because all of the library content are C/C++ macros that must be evaluated at compile time. In 2023 I prepared a talk about the Glass-To-Glass-Latency in Android . For my latency experiments I created a git repository and needed the above mentioned C/C++ library as a source dependency. I develop an Android Application that could perform various tests and experiments. The code of the application is on github in the repo inovex/android-glass-to-glass-latency . In this application I also used the Android NDK to write some C++ code to access some libc functions from Java and to trigger the torch light of the Pixel2 phone as fast as possible. And while written and testing the C++ code I needed to write some log messages. Therefore I imported my aminilog library as a source dependency into the project. The commands were roughly the following: $ mkdir external/ $ cd external/ $ git clone https://github.com/lengfeld/aminilog.git $ rm -rf aminilog/.git $ git add aminilog/ $ git commit -m \"add aminilog dependency\" And then I integrated the library into the cmake build systems by adding the line add_subdirectory(../../../../pixeltorch pixeltorch) [...] target_link_libraries(${PROJECT_NAME} android [...] aminilog) into the CMakeLists.txt . That was all. I added the source files of the aminilog library as files to the git repository android-glass-to-glass-latency and integrated them to the cmake build system. In this example the git repository android-glass-to-glass-latency is the superproject and the source dependency aminilog is the subproject. Example 2: Embedded Linux firmware based on Yocto This example illustrates a multi repository setup of a Yocto project. TODO add example Recap TODO write recap","title":"Introduction"},{"location":"exp/intro/#introduction","text":"Welcome to the realm of multi-repository management and third-party source dependencies. Even if you are an experienced software developer, you may not have encountered this issue in your career already. It only arises when working on larger software projects, managing inter-team software dependencies, or in the field of embedded software engineering. This page explains the issue with two examples: Example 1: C/C++ library as source dependency Example 2: multi repository project for linux embedded firmware","title":"Introduction"},{"location":"exp/intro/#example-1-cc-library-as-source-dependency","text":"This example illustrates a third party source dependency. I maintain a small C/C++ library called aminilog . It's useful when writing C/C++ code in an Android Application project that uses the Android NDK (Native Development toolkit). The library provides ready to use logging macros, because the NDK only contains the low level APIs for logging. I publish the library as a plain git repository. Since it is really simple, there are no release tarballs or tags and no binary artifacts. Also binary artifacts would do not make sense, because all of the library content are C/C++ macros that must be evaluated at compile time. In 2023 I prepared a talk about the Glass-To-Glass-Latency in Android . For my latency experiments I created a git repository and needed the above mentioned C/C++ library as a source dependency. I develop an Android Application that could perform various tests and experiments. The code of the application is on github in the repo inovex/android-glass-to-glass-latency . In this application I also used the Android NDK to write some C++ code to access some libc functions from Java and to trigger the torch light of the Pixel2 phone as fast as possible. And while written and testing the C++ code I needed to write some log messages. Therefore I imported my aminilog library as a source dependency into the project. The commands were roughly the following: $ mkdir external/ $ cd external/ $ git clone https://github.com/lengfeld/aminilog.git $ rm -rf aminilog/.git $ git add aminilog/ $ git commit -m \"add aminilog dependency\" And then I integrated the library into the cmake build systems by adding the line add_subdirectory(../../../../pixeltorch pixeltorch) [...] target_link_libraries(${PROJECT_NAME} android [...] aminilog) into the CMakeLists.txt . That was all. I added the source files of the aminilog library as files to the git repository android-glass-to-glass-latency and integrated them to the cmake build system. In this example the git repository android-glass-to-glass-latency is the superproject and the source dependency aminilog is the subproject.","title":"Example 1: C/C++ library as source dependency"},{"location":"exp/intro/#example-2-embedded-linux-firmware-based-on-yocto","text":"This example illustrates a multi repository setup of a Yocto project. TODO add example","title":"Example 2: Embedded Linux firmware based on Yocto"},{"location":"exp/intro/#recap","text":"TODO write recap","title":"Recap"},{"location":"ref/command-line/","text":"Command line arguments The subpatch command line tool uses the common argument structure with multiple arguments and one command. It is the same as other popular tools like git or docker . Examples: subpatch status subpatch add <url> -r <revision> Here status and add are commands and -r <revision is an optional argument. subpatch uses the argparse module of python. So the following commands are equivalent: subpatch add -r=<revision> <url> subpatch add -r<revision> <url> subpatch add -r <revision> <url> subpatch add <url> --revision=<revision> subpatch add <url> --revision <revision> subpatch status subpatch status Show the current state of all subprojects in the superproject. Much like git status . subpatch add subpatch add <url> [<path>] [--revision | -r <revision>] Add the subproject at url at the optional path in the current repository. Currently url can only point to a git repository. Other subproject types are not yet supported. The path is optional. If it's omitted the canonical subproject name is used. It's mostly the last folder name in the url . If path is provided it can include also sub directories. If no --revision argument is given, subpatch uses the remote default branch for git repositories. It's mostly the main branch, but the remote repository can configured also different branches as the default HEAD . -r,--revision : Specify the revision of the subproject that should be included in the superproject. For git repositories it can be a branch name, a tag name or a commit id. For performance you should give a branch name or tag name. The git protocol allows to clone a single branch or tag efficiently. For git commit ids subpatch needs to download the whole repository including all branches, tags and the complete history instead of just a single revision.","title":"Command line arguments"},{"location":"ref/command-line/#command-line-arguments","text":"The subpatch command line tool uses the common argument structure with multiple arguments and one command. It is the same as other popular tools like git or docker . Examples: subpatch status subpatch add <url> -r <revision> Here status and add are commands and -r <revision is an optional argument. subpatch uses the argparse module of python. So the following commands are equivalent: subpatch add -r=<revision> <url> subpatch add -r<revision> <url> subpatch add -r <revision> <url> subpatch add <url> --revision=<revision> subpatch add <url> --revision <revision>","title":"Command line arguments"},{"location":"ref/command-line/#subpatch-status","text":"subpatch status Show the current state of all subprojects in the superproject. Much like git status .","title":"subpatch status"},{"location":"ref/command-line/#subpatch-add","text":"subpatch add <url> [<path>] [--revision | -r <revision>] Add the subproject at url at the optional path in the current repository. Currently url can only point to a git repository. Other subproject types are not yet supported. The path is optional. If it's omitted the canonical subproject name is used. It's mostly the last folder name in the url . If path is provided it can include also sub directories. If no --revision argument is given, subpatch uses the remote default branch for git repositories. It's mostly the main branch, but the remote repository can configured also different branches as the default HEAD . -r,--revision : Specify the revision of the subproject that should be included in the superproject. For git repositories it can be a branch name, a tag name or a commit id. For performance you should give a branch name or tag name. The git protocol allows to clone a single branch or tag efficiently. For git commit ids subpatch needs to download the whole repository including all branches, tags and the complete history instead of just a single revision.","title":"subpatch add"},{"location":"ref/glossary/","text":"Glossary This page contains explanations of the terms in the context subpatch. The terms are not sorted alphabetically. They are sorted according to relevance. More important terms are at the top, less important terms are at the bottom. multi repository management/setup/problem The multi repository problem is when your project consists of multiple repositories and there are interdependencies between these repositories. E.g. when you must checkout multiple repos, because your build spans across multiple On this website the problem is sometimes called multi repository setup . The process of handling such a project is called multi repository management . superproject The superproject is the parent project in a multi repository setup. It's often a git repository itself, e.g. for git submodule . When using subpatch the superproject has the configuration file .subpatch at its top level directory. subproject(s) The subproject or subprojects are the external projects, often called (third party) dependencies, that are added to the superproject. Note : The terms super- and sub- projects are always relative to a specific project setup. It might be the case that the superproject of a project (e.g. a C library with third party dependencies) is the subproject of another project (e.g. a C++ application, using the library). Naming in different contexts The terms superproject/subproject and project/dependency are specific to a given context, but can be used interchangeably. Here is an overview: Context Name for super\u2026 Name for sub\u2026 package manager project/package (source) dependencies multi repo problem superproject subprojects multi repo problem super repository sub repositories multi repo problem superrepo subrepos version control system (vcs) A version control system is a tool to track changes to a set of files and provides auxiliary functional. Sometimes these are also called source code management tools. Popular version control systems are git subversion (svn) mercurial (hg) Concurrent Versions System (cvs) The older name for vcs is rcs ( revision control system ). And yet another (current) name is scm ( source control management ). Then name is used on the git website . application-level package manager (APM) The term application-level pakcage managers (APM) is used to described package managers provided in the ecosystem of the programming language. Examples: yarn for Javascript cargo for rust pip for python conan for C++ See also the Wikipedia entry Application-level package managers . These APMs are in contrast to package managers of Linux distributions, like rpm and dpkg, and embedded build systems, like buildroot and Yocto.","title":"Glossary"},{"location":"ref/glossary/#glossary","text":"This page contains explanations of the terms in the context subpatch. The terms are not sorted alphabetically. They are sorted according to relevance. More important terms are at the top, less important terms are at the bottom.","title":"Glossary"},{"location":"ref/glossary/#multi-repository-managementsetupproblem","text":"The multi repository problem is when your project consists of multiple repositories and there are interdependencies between these repositories. E.g. when you must checkout multiple repos, because your build spans across multiple On this website the problem is sometimes called multi repository setup . The process of handling such a project is called multi repository management .","title":"multi repository management/setup/problem"},{"location":"ref/glossary/#superproject","text":"The superproject is the parent project in a multi repository setup. It's often a git repository itself, e.g. for git submodule . When using subpatch the superproject has the configuration file .subpatch at its top level directory.","title":"superproject"},{"location":"ref/glossary/#subprojects","text":"The subproject or subprojects are the external projects, often called (third party) dependencies, that are added to the superproject. Note : The terms super- and sub- projects are always relative to a specific project setup. It might be the case that the superproject of a project (e.g. a C library with third party dependencies) is the subproject of another project (e.g. a C++ application, using the library).","title":"subproject(s)"},{"location":"ref/glossary/#naming-in-different-contexts","text":"The terms superproject/subproject and project/dependency are specific to a given context, but can be used interchangeably. Here is an overview: Context Name for super\u2026 Name for sub\u2026 package manager project/package (source) dependencies multi repo problem superproject subprojects multi repo problem super repository sub repositories multi repo problem superrepo subrepos","title":"Naming in different contexts"},{"location":"ref/glossary/#version-control-system-vcs","text":"A version control system is a tool to track changes to a set of files and provides auxiliary functional. Sometimes these are also called source code management tools. Popular version control systems are git subversion (svn) mercurial (hg) Concurrent Versions System (cvs) The older name for vcs is rcs ( revision control system ). And yet another (current) name is scm ( source control management ). Then name is used on the git website .","title":"version control system (vcs)"},{"location":"ref/glossary/#application-level-package-manager-apm","text":"The term application-level pakcage managers (APM) is used to described package managers provided in the ecosystem of the programming language. Examples: yarn for Javascript cargo for rust pip for python conan for C++ See also the Wikipedia entry Application-level package managers . These APMs are in contrast to package managers of Linux distributions, like rpm and dpkg, and embedded build systems, like buildroot and Yocto.","title":"application-level package manager (APM)"},{"location":"ref/releases/","text":"Releases This page lists all subpatch release with the release notes. The order is: newest/latest releases are at the top, oldest releases are at the bottom. v0.1a3 Second release of subpatch. The add command supports the -r | --revision command line argument and you can add multiple subprojects to a superproject. So some more basic things are covered. It's somehow useful now. Links: github release page subpatch (standalone python script) v0.1a2 First release of subpatch. For now it supports only two commands: add and status with a very limited amount of functionality. Links: github release page subpatch (standalone python script)","title":"Releases"},{"location":"ref/releases/#releases","text":"This page lists all subpatch release with the release notes. The order is: newest/latest releases are at the top, oldest releases are at the bottom.","title":"Releases"},{"location":"ref/releases/#v01a3","text":"Second release of subpatch. The add command supports the -r | --revision command line argument and you can add multiple subprojects to a superproject. So some more basic things are covered. It's somehow useful now. Links: github release page subpatch (standalone python script)","title":"v0.1a3"},{"location":"ref/releases/#v01a2","text":"First release of subpatch. For now it supports only two commands: add and status with a very limited amount of functionality. Links: github release page subpatch (standalone python script)","title":"v0.1a2"},{"location":"tut/basic-usage/","text":"Basic usage This tutorial explains how to add a third party dependency with subpatch to a git repository. In this tutorial the superproject is a simple C-library project that contains a function that adds two numbers. The subproject (=third party dependency) is the GoogleTest test library for C and C++ projects. Prerequisites To follow the tutorial you need the following setup Basic knowledge of git and the command line git installed subpatch installed (See Installation for the details) (optional) cmake and a c/c++ compiler installed Cloning the example repository First you need to clone the example repository . It's the superproject that contains minimal C library. On the command line execute $ git clone https://github.com/lengfeld/subpatch-example0 $ cd subpatch-example0 If interested, have a look at the README.md file. (optional) Buliding the C project If you want, you can also build the C library and test the example program. You need cmake and a c/c++ compiler for that. Execute the commands $ cmake -B build . $ cmake --build build $ build/prog 9 7 16 Adding the third party dependency The example project contains the file test.cc . It is currently unused, because the GoogleTest dependency is missing. You will add it shortly. As a good practice you should add all third party dependencies in a subfolder called external . To add the dependency execute the commands $ mkdir external $ cd external $ subpatch add https://github.com/google/googletest -r v1.15.2 The last command takes some seconds to execute. It downloads the git repository and extract the files. It uses revision v1.15.2 of the git repository. It's a git tag that points to the current latest release of googletest. When the command finishes it prints the message Adding subproject 'https://github.com/google/googletest' into 'googletest'... Done. - To inspect the changes, use `git status` and `git diff --staged`. - If you want to keep the changes, commit them with `git commit`. - If you want to revert the changes, execute `git reset --merge`. The message contains three different options. To see what subpatch added to the git index, execute $ git status There are around 240 new files. Commit them by executing $ cd .. $ git commit -m \"external: Adding GooglTest dependency\" Info: Apart from the files of the third party dependency subpatch also adds some metadata to the superproject. You can find it a the root directory of the git repository in the file .subpatch . For this tutorial the content looks like [subpatch \"external/googletest\"] url = https://github.com/google/googletest (optional) Enable and build the tests After adding the GoogleTest dependency, you can build and execute the tests. Open the CMakeLists.txt file and enable them. You can find the needed cmake configuration already in the file, just remove the comments. Now the last lines of the file should look like # Tests add_subdirectory(external/googletest gtest) add_executable(test test.cc) target_link_libraries(test GTest::gtest_main add) include(GoogleTest) gtest_discover_tests(test) After that you can build and run the tests with $ cmake --build build $ build/test Executing the last command will perform all tests and show the test results. All tests should pass! Congratulations Congratulations! You have added your first subproject with subpatch.","title":"Basic usage"},{"location":"tut/basic-usage/#basic-usage","text":"This tutorial explains how to add a third party dependency with subpatch to a git repository. In this tutorial the superproject is a simple C-library project that contains a function that adds two numbers. The subproject (=third party dependency) is the GoogleTest test library for C and C++ projects.","title":"Basic usage"},{"location":"tut/basic-usage/#prerequisites","text":"To follow the tutorial you need the following setup Basic knowledge of git and the command line git installed subpatch installed (See Installation for the details) (optional) cmake and a c/c++ compiler installed","title":"Prerequisites"},{"location":"tut/basic-usage/#cloning-the-example-repository","text":"First you need to clone the example repository . It's the superproject that contains minimal C library. On the command line execute $ git clone https://github.com/lengfeld/subpatch-example0 $ cd subpatch-example0 If interested, have a look at the README.md file.","title":"Cloning the example repository"},{"location":"tut/basic-usage/#optional-buliding-the-c-project","text":"If you want, you can also build the C library and test the example program. You need cmake and a c/c++ compiler for that. Execute the commands $ cmake -B build . $ cmake --build build $ build/prog 9 7 16","title":"(optional) Buliding the C project"},{"location":"tut/basic-usage/#adding-the-third-party-dependency","text":"The example project contains the file test.cc . It is currently unused, because the GoogleTest dependency is missing. You will add it shortly. As a good practice you should add all third party dependencies in a subfolder called external . To add the dependency execute the commands $ mkdir external $ cd external $ subpatch add https://github.com/google/googletest -r v1.15.2 The last command takes some seconds to execute. It downloads the git repository and extract the files. It uses revision v1.15.2 of the git repository. It's a git tag that points to the current latest release of googletest. When the command finishes it prints the message Adding subproject 'https://github.com/google/googletest' into 'googletest'... Done. - To inspect the changes, use `git status` and `git diff --staged`. - If you want to keep the changes, commit them with `git commit`. - If you want to revert the changes, execute `git reset --merge`. The message contains three different options. To see what subpatch added to the git index, execute $ git status There are around 240 new files. Commit them by executing $ cd .. $ git commit -m \"external: Adding GooglTest dependency\" Info: Apart from the files of the third party dependency subpatch also adds some metadata to the superproject. You can find it a the root directory of the git repository in the file .subpatch . For this tutorial the content looks like [subpatch \"external/googletest\"] url = https://github.com/google/googletest","title":"Adding the third party dependency"},{"location":"tut/basic-usage/#optional-enable-and-build-the-tests","text":"After adding the GoogleTest dependency, you can build and execute the tests. Open the CMakeLists.txt file and enable them. You can find the needed cmake configuration already in the file, just remove the comments. Now the last lines of the file should look like # Tests add_subdirectory(external/googletest gtest) add_executable(test test.cc) target_link_libraries(test GTest::gtest_main add) include(GoogleTest) gtest_discover_tests(test) After that you can build and run the tests with $ cmake --build build $ build/test Executing the last command will perform all tests and show the test results. All tests should pass!","title":"(optional) Enable and build the tests"},{"location":"tut/basic-usage/#congratulations","text":"Congratulations! You have added your first subproject with subpatch.","title":"Congratulations"},{"location":"tut/installation/","text":"Installation This tutorial explains who to install subpatch on your computer. Currently there are two ways to install subpatch: With pipx into your HOME directory As a standalone script into the PATH NOTE : subpatch is currently in a very very early stage. Do not use it in production environments! Prerequisites To follow this tutorial you need a PC or notebook with a Linux Operating System installed. This tutorial will assume Ubuntu , but any current distribution should work. Also MacOS may work out of the box, but it's not tested for now. With pipx into your HOME directory The subpatch project is released on PyPI , the \"Python Package Index\". The PyPI's subpatch site contains the project specific informations. Install pipx To install subpatch, you can use pipx . pipx is a tool to manage python virtual environments in your HOME directory. To install pipx on Ubuntu, execute $ sudo apt install pipx NOTE : For other distributions use the distro specific package manager. To check if pipx works, you can execute the list command. An example: $ pipx list nothing has been installed with pipx \ud83d\ude34 Install subpatch with pipx If everything is fine, you can install the latest version of subpatch with the command $ pipx install subpatch The output of the command should look like installed package subpatch 0.1a2, installed using Python 3.10.12 These apps are now globally available - subpatch done! \u2728 \ud83c\udf1f \u2728 If some of the numbers are different, that's o.k. To test that subpatch works, you can execute the command $ subpatch --version It should print the version number of subpatch that is currently installed. Congratulations , now you successfully installed subpatch. A final note: To get further infos and the help text, execute $ subpatch --help As a standalone script into the PATH You can also install subpatch as a standalone python script into your PATH. Create a bin folder First make sure that you have a directory that is listed in your PATH. If you have another folder in the PATH for other scripts already, you can skip this step. I used a bin directory in the HOME folder for that. To create it, execute $ mkdir ~/bin Then this folder must be added to the environment variable PATH. This can be done with $ echo 'export PATH=$PATH:$HOME/bin' >> ~/.bashrc It adds a line at the end of the ~./bashrc file. The change will only be active in new shells that are spawned now. So start a new shell with $ bash NOTE : This tutorial assumes that you are using bash. If you use another shell, like zsh or fish, you mostly already know everything in the tutorial and can adapt it yourself :-) To check that the modifications of the PATH variable worked, execute $ echo $PATH It prints all folders that are scanned for executable files. The list should contain the bin folder in your HOME directory at the end. Download and install subpatch The last step is to download the subpatch script and copy it into the bin folder. First go to the releases page and find the latest release. There are two options: manual download or using the command line: Manual download Now click on the link for standalone python script and download the script with your browser. After you downloaded the standalone script into your download directory, you must move it to the bin directory. For example: $ mv subpatch ~/bin/ The executable bit is not set for downloaded files. You must manually set it with the command $ chmod +x ~/bin/subpatch Otherwise the shell cannot execute the script. Using the command line Apart from the manual download, you can use command line tools. To download the script and set the executable bit, just execute: $ wget https://github.com/lengfeld/subpatch/releases/download/v0.1a2/subpatch -O ~/bin/subpatch $ chmod +x ~/bin/subpatch The above command is just an example. For other versions of subpatch, the version number in the URL looks different. Test subpatch After download and installation you should test the subpatch command line tool. To test that it works, you can execute the command $ subpatch --version It should print the version number of subpatch that is currently installed. Congratulations , now you successfully installed subpatch. A final note: To get further infos and the help text, execute $ subpatch --help","title":"Installation"},{"location":"tut/installation/#installation","text":"This tutorial explains who to install subpatch on your computer. Currently there are two ways to install subpatch: With pipx into your HOME directory As a standalone script into the PATH NOTE : subpatch is currently in a very very early stage. Do not use it in production environments!","title":"Installation"},{"location":"tut/installation/#prerequisites","text":"To follow this tutorial you need a PC or notebook with a Linux Operating System installed. This tutorial will assume Ubuntu , but any current distribution should work. Also MacOS may work out of the box, but it's not tested for now.","title":"Prerequisites"},{"location":"tut/installation/#with-pipx-into-your-home-directory","text":"The subpatch project is released on PyPI , the \"Python Package Index\". The PyPI's subpatch site contains the project specific informations.","title":"With pipx into your HOME directory"},{"location":"tut/installation/#install-pipx","text":"To install subpatch, you can use pipx . pipx is a tool to manage python virtual environments in your HOME directory. To install pipx on Ubuntu, execute $ sudo apt install pipx NOTE : For other distributions use the distro specific package manager. To check if pipx works, you can execute the list command. An example: $ pipx list nothing has been installed with pipx \ud83d\ude34","title":"Install pipx"},{"location":"tut/installation/#install-subpatch-with-pipx","text":"If everything is fine, you can install the latest version of subpatch with the command $ pipx install subpatch The output of the command should look like installed package subpatch 0.1a2, installed using Python 3.10.12 These apps are now globally available - subpatch done! \u2728 \ud83c\udf1f \u2728 If some of the numbers are different, that's o.k. To test that subpatch works, you can execute the command $ subpatch --version It should print the version number of subpatch that is currently installed. Congratulations , now you successfully installed subpatch. A final note: To get further infos and the help text, execute $ subpatch --help","title":"Install subpatch with pipx"},{"location":"tut/installation/#as-a-standalone-script-into-the-path","text":"You can also install subpatch as a standalone python script into your PATH.","title":"As a standalone script into the PATH"},{"location":"tut/installation/#create-a-bin-folder","text":"First make sure that you have a directory that is listed in your PATH. If you have another folder in the PATH for other scripts already, you can skip this step. I used a bin directory in the HOME folder for that. To create it, execute $ mkdir ~/bin Then this folder must be added to the environment variable PATH. This can be done with $ echo 'export PATH=$PATH:$HOME/bin' >> ~/.bashrc It adds a line at the end of the ~./bashrc file. The change will only be active in new shells that are spawned now. So start a new shell with $ bash NOTE : This tutorial assumes that you are using bash. If you use another shell, like zsh or fish, you mostly already know everything in the tutorial and can adapt it yourself :-) To check that the modifications of the PATH variable worked, execute $ echo $PATH It prints all folders that are scanned for executable files. The list should contain the bin folder in your HOME directory at the end.","title":"Create a bin folder"},{"location":"tut/installation/#download-and-install-subpatch","text":"The last step is to download the subpatch script and copy it into the bin folder. First go to the releases page and find the latest release. There are two options: manual download or using the command line:","title":"Download and install subpatch"},{"location":"tut/installation/#manual-download","text":"Now click on the link for standalone python script and download the script with your browser. After you downloaded the standalone script into your download directory, you must move it to the bin directory. For example: $ mv subpatch ~/bin/ The executable bit is not set for downloaded files. You must manually set it with the command $ chmod +x ~/bin/subpatch Otherwise the shell cannot execute the script.","title":"Manual download"},{"location":"tut/installation/#using-the-command-line","text":"Apart from the manual download, you can use command line tools. To download the script and set the executable bit, just execute: $ wget https://github.com/lengfeld/subpatch/releases/download/v0.1a2/subpatch -O ~/bin/subpatch $ chmod +x ~/bin/subpatch The above command is just an example. For other versions of subpatch, the version number in the URL looks different.","title":"Using the command line"},{"location":"tut/installation/#test-subpatch","text":"After download and installation you should test the subpatch command line tool. To test that it works, you can execute the command $ subpatch --version It should print the version number of subpatch that is currently installed. Congratulations , now you successfully installed subpatch. A final note: To get further infos and the help text, execute $ subpatch --help","title":"Test subpatch"}]}