{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"subpatch: fearless multi-repository management - stay relaxed! Welcome to the website of subpatch. The tool that does multi-repository management right. Don't worry, stay relaxed! Currently this project is just an idea. No code yet. But the general concept is already proven and works! The subpatch project will provide two things: A command line tool called subpatch to manage subprojects in a source control repository, e.g. in a git repository. The github repository is subpatch . Documentation, explanations and opinions about multi repo setups and management. This is this website. If you are currently using git-submodules or repo and you are frustrated, subpatch will be mostly your solution! If you are interested, email me . subpatch usecases subpatch is interesting for you if you want to do the following tasks: assemble a monorepo from multiple repositories integrate third party dependencies into your project as source files maintain a local fork (=linear patchstack) of a third party dependency subpatch's concept subpatch will be a subprojects management tool based on the following ideas: It's based on the idea of git add and git read-tree . The files of subprojects are added as normal files to the superproject. In most cases this will be just a git repository. The metadata of a subproject is saved in a git-config styled configuration file. Modifications of the subproject are possible and subpatch helps to maintain a linear patch stack of the modifications. Importing new versions of the subproject is possible and subpatch helps to rebase the local modifications. subpatch main difference When you use subpatch the subprojects are not git repository itself. The files of the subprojects are added as files to the superproject. You will only have to deal with a single git repository. This is in contrast to other tools, e.g. git-submodules repo kas west These tools manage multi git repository management and try to combine them into a big superproject.","title":"Home"},{"location":"#subpatch-fearless-multi-repository-management-stay-relaxed","text":"Welcome to the website of subpatch. The tool that does multi-repository management right. Don't worry, stay relaxed! Currently this project is just an idea. No code yet. But the general concept is already proven and works! The subpatch project will provide two things: A command line tool called subpatch to manage subprojects in a source control repository, e.g. in a git repository. The github repository is subpatch . Documentation, explanations and opinions about multi repo setups and management. This is this website. If you are currently using git-submodules or repo and you are frustrated, subpatch will be mostly your solution! If you are interested, email me .","title":"subpatch: fearless multi-repository management - stay relaxed!"},{"location":"#subpatch-usecases","text":"subpatch is interesting for you if you want to do the following tasks: assemble a monorepo from multiple repositories integrate third party dependencies into your project as source files maintain a local fork (=linear patchstack) of a third party dependency","title":"subpatch usecases"},{"location":"#subpatchs-concept","text":"subpatch will be a subprojects management tool based on the following ideas: It's based on the idea of git add and git read-tree . The files of subprojects are added as normal files to the superproject. In most cases this will be just a git repository. The metadata of a subproject is saved in a git-config styled configuration file. Modifications of the subproject are possible and subpatch helps to maintain a linear patch stack of the modifications. Importing new versions of the subproject is possible and subpatch helps to rebase the local modifications.","title":"subpatch's concept"},{"location":"#subpatch-main-difference","text":"When you use subpatch the subprojects are not git repository itself. The files of the subprojects are added as files to the superproject. You will only have to deal with a single git repository. This is in contrast to other tools, e.g. git-submodules repo kas west These tools manage multi git repository management and try to combine them into a big superproject.","title":"subpatch main difference"},{"location":"imprint/","text":"Imprint This website is created and maintained by name: Stefan Lengfeld address: Germany, 53721 Siegburg e-mail: stefan+subpatch@lengfeld.xyz The website's source is available in the folder website/ in the subpatch repository .","title":"Imprint"},{"location":"imprint/#imprint","text":"This website is created and maintained by name: Stefan Lengfeld address: Germany, 53721 Siegburg e-mail: stefan+subpatch@lengfeld.xyz The website's source is available in the folder website/ in the subpatch repository .","title":"Imprint"},{"location":"exp/comparison/","text":"Comparison to other tools Subpatch is not the first tool that tries to solve the multi repository problem. Other tools are git-submodules repo kas west git-subtree This page will compare these tools with subpatch. Technical comparison The following table compares the architecture of the tools subpatch repo git submodule west kas subtree config format git-cfg xml git-cfg ??? yaml none superproject any(1) none git git git git subprojects any(1) git git git git git Explanations of the rows: config format : The format of the config file that is used to track the information about the subprojects. superproject : This is the type of cvs that is the top level repository and also (often) tracks the configuration of subprojects. The repo tool is special here: It tracks the subprojects in a manifest file in a separate git repository, the so called manifest repository . But this repository is not part of the directory hierarchy when the project is checked out. It does not sit at the top level of the superproject. subprojects : This is the type of cvs that is support as a subproject. For all other tools, except subpatch, only other git repositories are supported. Legend: git-cfg stands for the git config format used in .git/config , ~/.gitconfig and .gitmodules . (1) : subpatch does not support all other cvs as super- and subprojects for now. Still work in progress.","title":"Comparison to other tools"},{"location":"exp/comparison/#comparison-to-other-tools","text":"Subpatch is not the first tool that tries to solve the multi repository problem. Other tools are git-submodules repo kas west git-subtree This page will compare these tools with subpatch.","title":"Comparison to other tools"},{"location":"exp/comparison/#technical-comparison","text":"The following table compares the architecture of the tools subpatch repo git submodule west kas subtree config format git-cfg xml git-cfg ??? yaml none superproject any(1) none git git git git subprojects any(1) git git git git git Explanations of the rows: config format : The format of the config file that is used to track the information about the subprojects. superproject : This is the type of cvs that is the top level repository and also (often) tracks the configuration of subprojects. The repo tool is special here: It tracks the subprojects in a manifest file in a separate git repository, the so called manifest repository . But this repository is not part of the directory hierarchy when the project is checked out. It does not sit at the top level of the superproject. subprojects : This is the type of cvs that is support as a subproject. For all other tools, except subpatch, only other git repositories are supported. Legend: git-cfg stands for the git config format used in .git/config , ~/.gitconfig and .gitmodules . (1) : subpatch does not support all other cvs as super- and subprojects for now. Still work in progress.","title":"Technical comparison"},{"location":"exp/design/","text":"subpatch design subpatch is based on my experiences and learnings as a (embedded) software engineer. Everything that I have seen and done in the last ten years feeds into the following list of requirements. NOTE : For now the implementation of subpatch not complete. Please read the requirement list as a vision for the first major release of subpatch, not as a status of the implementation. Requirements The tool \u2026 ( R1 ) should support git, cvs, mercurial, subversion and non-cvs environment as superprojects. ( R2 ) do not interfere with the vcs. The existing workflows like checking out, cloning, switching branches, updating, rebasing, tagging, forking, bisecting, releasing and ... should stay the same. ( R3 ) should support git, cvs, mercurial, subversion and source code archives (like tarballs or zip files) as source dependencies ( R4 ) should track the original metadata (e.g. url, commit ids, checksums, ... ) of the source dependency to verify the authenticity of the dependency later. ( R5 ) should help integrating updates of the source dependencies. ( R6 ) should support local patching of source dependencies. ( R7 ) If the source dependency is patched locally, it should help maintaining a linear patch stack. ( R8 ) When doing an update of a source dependency and there are no conflicts with the local patches, the tool should rebase local patches automatically. ( R9 ) When doing an update of a source dependency and there are are conflicts with the local patches, the tool should help porting the local patches. ( R10 ) should provided an stable command line API (plumbing commands) to support other tools to track source dependencies, e.g. to automatically check for updates or for CVEs. ( R11 ) Should support every development platform that also supports git and python, like Linux, unixes, Windows and MacOS. ( R12 ) Should scale to the size of the AOSP (Android Open Source Project) Design Decisions While developing subpatch, the following design decisions were taken. The requirement list still still gives a lot of freedom for the implementation. Therefore the chosen decisions are documented and explained here. ( DD1 ): written in python3 (but open for a port to another later if successful) [+] faster iteration speed [+] easier deployment/install of users. python runs everywhere. [+] programming language that I know really good and written a lot of code already. ( DD2 ): config file format is git-config [+] the same config format that the main cvs for subpatch (=git) uses. [+] Most developers are already familiar with the config format, e.g. because they are modyfing ~/.git config . NOTE: This list is not completed yet and should grow while supbatch is developed.","title":"subpatch design"},{"location":"exp/design/#subpatch-design","text":"subpatch is based on my experiences and learnings as a (embedded) software engineer. Everything that I have seen and done in the last ten years feeds into the following list of requirements. NOTE : For now the implementation of subpatch not complete. Please read the requirement list as a vision for the first major release of subpatch, not as a status of the implementation.","title":"subpatch design"},{"location":"exp/design/#requirements","text":"The tool \u2026 ( R1 ) should support git, cvs, mercurial, subversion and non-cvs environment as superprojects. ( R2 ) do not interfere with the vcs. The existing workflows like checking out, cloning, switching branches, updating, rebasing, tagging, forking, bisecting, releasing and ... should stay the same. ( R3 ) should support git, cvs, mercurial, subversion and source code archives (like tarballs or zip files) as source dependencies ( R4 ) should track the original metadata (e.g. url, commit ids, checksums, ... ) of the source dependency to verify the authenticity of the dependency later. ( R5 ) should help integrating updates of the source dependencies. ( R6 ) should support local patching of source dependencies. ( R7 ) If the source dependency is patched locally, it should help maintaining a linear patch stack. ( R8 ) When doing an update of a source dependency and there are no conflicts with the local patches, the tool should rebase local patches automatically. ( R9 ) When doing an update of a source dependency and there are are conflicts with the local patches, the tool should help porting the local patches. ( R10 ) should provided an stable command line API (plumbing commands) to support other tools to track source dependencies, e.g. to automatically check for updates or for CVEs. ( R11 ) Should support every development platform that also supports git and python, like Linux, unixes, Windows and MacOS. ( R12 ) Should scale to the size of the AOSP (Android Open Source Project)","title":"Requirements"},{"location":"exp/design/#design-decisions","text":"While developing subpatch, the following design decisions were taken. The requirement list still still gives a lot of freedom for the implementation. Therefore the chosen decisions are documented and explained here. ( DD1 ): written in python3 (but open for a port to another later if successful) [+] faster iteration speed [+] easier deployment/install of users. python runs everywhere. [+] programming language that I know really good and written a lot of code already. ( DD2 ): config file format is git-config [+] the same config format that the main cvs for subpatch (=git) uses. [+] Most developers are already familiar with the config format, e.g. because they are modyfing ~/.git config . NOTE: This list is not completed yet and should grow while supbatch is developed.","title":"Design Decisions"},{"location":"exp/history/","text":"Pre-subpatch history subpatch is not my first attempt to solve the multi repository problem. There is a longer history before I started the subpatch project. This page should tell my path in this problem space and what learings I made along the way. TODO write history and define learnings as ( L? )","title":"Pre-subpatch history"},{"location":"exp/history/#pre-subpatch-history","text":"subpatch is not my first attempt to solve the multi repository problem. There is a longer history before I started the subpatch project. This page should tell my path in this problem space and what learings I made along the way. TODO write history and define learnings as ( L? )","title":"Pre-subpatch history"},{"location":"exp/intro/","text":"Introduction This page should introduce you to the problem space of multi repository management and third party source dependencies. It's not a common problem for every software developers. The problem only arises when dealing for bigger software products, inter team software dependencies and in embedded software engineering. This page explains the issue with two examples: Example 1: C/C++ library as source dependency Example 2: Embedded Linux firmware based on Yocto Example 1: C/C++ library as source dependency This example illustrates a third party source dependency. I publish a small C/C++ library aminilog . It's useful when writing C/C++ code in a Android Application project that uses the Android NDK (Native Development toolkit). The library provides ready to use logging macros, so a developer does need to write the logging macros for every NDK project from scratch. The library is only publish as a git repository. It's really simple. So there are no releases or tags and no binary artifacts, too. Also binary artifacts would do not make sense, because all of the library content are C/C++ Macros that must be evaluated at compile time of the user of the header. For a talk about the Glass-To-Glass-Latency in Android I made a lot of experiments on the Android platform and develop an Android Application that could perform various tests. I published the code of the application on github in the repo inovex/android-glass-to-glass-latency In this application I also used the Android NDK to write some C++ code to access some libc functions from Java and to trigger the torch light of the Pixel2 phone as fast as possible. And while written and testing the C++ code I needed to write some log messages. Therefore I have imported my aminilog library as a source dependency into the project. The commands were roughly the following: $ mkdir external/ $ cd external/ $ git clone https://github.com/lengfeld/aminilog.git $ rm -rf aminilog/.git $ git add aminilog/ $ git commit -m \"add aminilog dependency\" And then I integrate the library into the cmake build systems by adding the line add_subdirectory(../../../../pixeltorch pixeltorch) [...] target_link_libraries(${PROJECT_NAME} android [...] aminilog) into the CMakeLists.txt . In this example the git repository android-glass-to-glass-latency is the superproject and the source dependency aminilog is the subproject. Example 2: Embedded Linux firmware based on Yocto TODO add example Recap TODO write recap","title":"Introduction"},{"location":"exp/intro/#introduction","text":"This page should introduce you to the problem space of multi repository management and third party source dependencies. It's not a common problem for every software developers. The problem only arises when dealing for bigger software products, inter team software dependencies and in embedded software engineering. This page explains the issue with two examples: Example 1: C/C++ library as source dependency Example 2: Embedded Linux firmware based on Yocto","title":"Introduction"},{"location":"exp/intro/#example-1-cc-library-as-source-dependency","text":"This example illustrates a third party source dependency. I publish a small C/C++ library aminilog . It's useful when writing C/C++ code in a Android Application project that uses the Android NDK (Native Development toolkit). The library provides ready to use logging macros, so a developer does need to write the logging macros for every NDK project from scratch. The library is only publish as a git repository. It's really simple. So there are no releases or tags and no binary artifacts, too. Also binary artifacts would do not make sense, because all of the library content are C/C++ Macros that must be evaluated at compile time of the user of the header. For a talk about the Glass-To-Glass-Latency in Android I made a lot of experiments on the Android platform and develop an Android Application that could perform various tests. I published the code of the application on github in the repo inovex/android-glass-to-glass-latency In this application I also used the Android NDK to write some C++ code to access some libc functions from Java and to trigger the torch light of the Pixel2 phone as fast as possible. And while written and testing the C++ code I needed to write some log messages. Therefore I have imported my aminilog library as a source dependency into the project. The commands were roughly the following: $ mkdir external/ $ cd external/ $ git clone https://github.com/lengfeld/aminilog.git $ rm -rf aminilog/.git $ git add aminilog/ $ git commit -m \"add aminilog dependency\" And then I integrate the library into the cmake build systems by adding the line add_subdirectory(../../../../pixeltorch pixeltorch) [...] target_link_libraries(${PROJECT_NAME} android [...] aminilog) into the CMakeLists.txt . In this example the git repository android-glass-to-glass-latency is the superproject and the source dependency aminilog is the subproject.","title":"Example 1: C/C++ library as source dependency"},{"location":"exp/intro/#example-2-embedded-linux-firmware-based-on-yocto","text":"TODO add example","title":"Example 2: Embedded Linux firmware based on Yocto"},{"location":"exp/intro/#recap","text":"TODO write recap","title":"Recap"},{"location":"ref/glossary/","text":"Glossary This page is a glossary. More important terms are at the top. superproject The superproject is the parent project in a multi repository setup. It's often a git repository itself, e.g. for git submodule . When using subpatch the superproject has the configuration file .subpatch at its top level directory. subproject(s) The subproject or subprojects are the external projects, often called (third party) dependencies, that are added to the superproject. Note : The terms super- and sub- projects are always relative to a specific project setup. It might be the case that the superproject of a project (e.g. a C library with third party dependencies) is the subproject of another project (e.g. a C++ application, using the library). Naming in different contexts The terms superproject/subproject and project/dependency are specific to a given context, but can be used interchangeably. Here is an overview: Context Name for super* Name for sub* package manager project (source) dependencies multi repo problem superproject subprojects multi repo problem super repository sub repositories multi repo problem superrepo subrepos version control system (vcs) A version control system is a tool to track changes to a set of files and provides auxiliary functional. Sometimes these are also called source code management tools. Popular version control systems are git subversion (svn) mercurial Concurrent Versions System (cvs)","title":"Glossary"},{"location":"ref/glossary/#glossary","text":"This page is a glossary. More important terms are at the top.","title":"Glossary"},{"location":"ref/glossary/#superproject","text":"The superproject is the parent project in a multi repository setup. It's often a git repository itself, e.g. for git submodule . When using subpatch the superproject has the configuration file .subpatch at its top level directory.","title":"superproject"},{"location":"ref/glossary/#subprojects","text":"The subproject or subprojects are the external projects, often called (third party) dependencies, that are added to the superproject. Note : The terms super- and sub- projects are always relative to a specific project setup. It might be the case that the superproject of a project (e.g. a C library with third party dependencies) is the subproject of another project (e.g. a C++ application, using the library).","title":"subproject(s)"},{"location":"ref/glossary/#naming-in-different-contexts","text":"The terms superproject/subproject and project/dependency are specific to a given context, but can be used interchangeably. Here is an overview: Context Name for super* Name for sub* package manager project (source) dependencies multi repo problem superproject subprojects multi repo problem super repository sub repositories multi repo problem superrepo subrepos","title":"Naming in different contexts"},{"location":"ref/glossary/#version-control-system-vcs","text":"A version control system is a tool to track changes to a set of files and provides auxiliary functional. Sometimes these are also called source code management tools. Popular version control systems are git subversion (svn) mercurial Concurrent Versions System (cvs)","title":"version control system (vcs)"},{"location":"ref/releases/","text":"Releases This page lists all subpatch release with the release notes. The order is: newest/latest releases are at the top, oldest releases are at the bottom. v0.1a2 First release of subpatch. For now it supports only two commands: add and status with a very limited amount of functionality. Links: github release page subpatch (standalone python script)","title":"Releases"},{"location":"ref/releases/#releases","text":"This page lists all subpatch release with the release notes. The order is: newest/latest releases are at the top, oldest releases are at the bottom.","title":"Releases"},{"location":"ref/releases/#v01a2","text":"First release of subpatch. For now it supports only two commands: add and status with a very limited amount of functionality. Links: github release page subpatch (standalone python script)","title":"v0.1a2"},{"location":"tut/basic-usage/","text":"Basic usage This tutorial explains how to add a third party dependency with subpatch to a git repository. In this tutorial the superproject is a simple C-library project that contains a function that adds two numbers. The subproject (=third party dependency) is the GoogleTest test library for C and C++ projects. Prerequisites To follow the tutorial you need the following setup Basic knowledge of git and the command line git installed subpatch installed (See Installation for the details) (optional) cmake and a c/c++ compiler installed Cloning the example repository First you need to clone the example repository . It's the superproject that contains minimal C library . On the command line execute $ git clone https://github.com/lengfeld/subpatch-example0 $ cd subpatch-example0 If interested, have a look at the README.md file. (optional) Buliding the C project If you want, you can also build the C library and test the example program. You need cmake and a c/c++ compiler for that. Execute the commands $ cmake -B build . $ cmake --build build $ build/prog 9 7 16 Adding the third party dependency The example project contains the file test.cc . It is currently unused, because the GoogleTest dependency is missing. You will add it shortly. As a good practice you should add all third party dependencies in a subfolder called external . To add the dependency execute the commands $ mkdir external $ cd external $ subpatch add https://github.com/google/googletest The last command takes some seconds to execute. It downloads the git repository and extract the files. It uses the default branch of the git repository. In most cases this is the main or the master branch. If you want to download another branch or tag, you must use an additional argument ( NOTE: this argument is not implemented yet). When the command finishes it prints the message Adding subproject 'googletest' was successful. - To inspect the changes, use `git status` and `git diff --staged`. - If you want to keep the changes, commit them with `git commit`. - If you want to revert the changes, execute 'git reset --merge`. The message contains three different options. To see what subpatch added to the git index, execute $ git status There are around 240 new files. Commit them by executing $ cd .. $ git commit -m \"external: Adding GooglTest dependency\" Info : Apart from the files of the third party dependency subpatch also adds some metadata to the superproject. You can find it a the root directory of the git repository in the file .subpatch . For this tutorial the content looks like [subpatch \"external/googletest\"] url = https://github.com/google/googletest (optional) Enable and build the tests After adding the GoogleTest dependency, you can build and execute the tests. Open the CMakeLists.txt file and enable them. You can find the needed cmake configuration already in the file, just remove the comments. Now the last lines of the file should look like # Tests add_subdirectory(external/googletest.git gtest) add_executable(test test.cc) target_link_libraries(test GTest::gtest_main add) include(GoogleTest) gtest_discover_tests(test) After that you can build and run the tests with $ cmake --build build $ build/test Executing the last command will perform all tests and show the test results. All tests should pass! Congratulations Congratulations! You have added your first subproject with subpatch.","title":"Basic usage"},{"location":"tut/basic-usage/#basic-usage","text":"This tutorial explains how to add a third party dependency with subpatch to a git repository. In this tutorial the superproject is a simple C-library project that contains a function that adds two numbers. The subproject (=third party dependency) is the GoogleTest test library for C and C++ projects.","title":"Basic usage"},{"location":"tut/basic-usage/#prerequisites","text":"To follow the tutorial you need the following setup Basic knowledge of git and the command line git installed subpatch installed (See Installation for the details) (optional) cmake and a c/c++ compiler installed","title":"Prerequisites"},{"location":"tut/basic-usage/#cloning-the-example-repository","text":"First you need to clone the example repository . It's the superproject that contains minimal C library . On the command line execute $ git clone https://github.com/lengfeld/subpatch-example0 $ cd subpatch-example0 If interested, have a look at the README.md file.","title":"Cloning the example repository"},{"location":"tut/basic-usage/#optional-buliding-the-c-project","text":"If you want, you can also build the C library and test the example program. You need cmake and a c/c++ compiler for that. Execute the commands $ cmake -B build . $ cmake --build build $ build/prog 9 7 16","title":"(optional) Buliding the C project"},{"location":"tut/basic-usage/#adding-the-third-party-dependency","text":"The example project contains the file test.cc . It is currently unused, because the GoogleTest dependency is missing. You will add it shortly. As a good practice you should add all third party dependencies in a subfolder called external . To add the dependency execute the commands $ mkdir external $ cd external $ subpatch add https://github.com/google/googletest The last command takes some seconds to execute. It downloads the git repository and extract the files. It uses the default branch of the git repository. In most cases this is the main or the master branch. If you want to download another branch or tag, you must use an additional argument ( NOTE: this argument is not implemented yet). When the command finishes it prints the message Adding subproject 'googletest' was successful. - To inspect the changes, use `git status` and `git diff --staged`. - If you want to keep the changes, commit them with `git commit`. - If you want to revert the changes, execute 'git reset --merge`. The message contains three different options. To see what subpatch added to the git index, execute $ git status There are around 240 new files. Commit them by executing $ cd .. $ git commit -m \"external: Adding GooglTest dependency\" Info : Apart from the files of the third party dependency subpatch also adds some metadata to the superproject. You can find it a the root directory of the git repository in the file .subpatch . For this tutorial the content looks like [subpatch \"external/googletest\"] url = https://github.com/google/googletest","title":"Adding the third party dependency"},{"location":"tut/basic-usage/#optional-enable-and-build-the-tests","text":"After adding the GoogleTest dependency, you can build and execute the tests. Open the CMakeLists.txt file and enable them. You can find the needed cmake configuration already in the file, just remove the comments. Now the last lines of the file should look like # Tests add_subdirectory(external/googletest.git gtest) add_executable(test test.cc) target_link_libraries(test GTest::gtest_main add) include(GoogleTest) gtest_discover_tests(test) After that you can build and run the tests with $ cmake --build build $ build/test Executing the last command will perform all tests and show the test results. All tests should pass!","title":"(optional) Enable and build the tests"},{"location":"tut/basic-usage/#congratulations","text":"Congratulations! You have added your first subproject with subpatch.","title":"Congratulations"},{"location":"tut/installation/","text":"Installation This tutorial explains who to install subpatch on your computer. Currently there are two ways to install subpatch: With pipx into your HOME directory As a standalone script into the PATH NOTE : subpatch is currently in a very very early stage. Do not use it in production environments! Prerequisites To follow this tutorial you need a PC or notebook with a Linux Operating System installed. This tutorial will assume Ubuntu , but any current distribution should work. Also MacOS may work out of the box, but it's not tested for now. With pipx into your HOME directory The subpatch project is released on PyPI , the \"Python Package Index\". The PyPI's subpatch site contains the project specific informations. Install pipx To install subpatch, you can use pipx . pipx is a tool to manage python virtual environments in your HOME directory. To install pipx on Ubuntu, execute $ sudo apt install pipx NOTE : For other distributions use the distro specific package manager. To check if pipx works, you can execute the list command. An example: $ pipx list nothing has been installed with pipx \ud83d\ude34 Install subpatch with pipx If everything is fine, you can install the latest version of subpatch with the command $ pipx install subpatch The output of the command should look like installed package subpatch 0.1a2, installed using Python 3.10.12 These apps are now globally available - subpatch done! \u2728 \ud83c\udf1f \u2728 If some of the numbers are different, that's o.k. To test that subpatch works, you can execute the command $ subpatch --version It should print the version number of subpatch that is currently installed. Congratulations , now you successfully installed subpatch. A final note: To get further infos and the help text, execute $ subpatch --help As a standalone script into the PATH You can also install subpatch as a standalone python script into your PATH. Create a bin folder First make sure that you have a directory that is listed in your PATH. If you have another folder in the PATH for other scripts already, you can skip this step. I used a bin directory in the HOME folder for that. To create it, execute $ mkdir ~/bin Then this folder must be added to the environment variable PATH. This can be done with $ echo 'export PATH=$PATH:$HOME/bin' >> ~/.bashrc It adds a line at the end of the ~./bashrc file. The change will only be active in new shells that are spawned now. So start a new shell with $ bash NOTE : This tutorial assumes that you are using bash. If you use another shell, like zsh or fish, you mostly already know everything in the tutorial and can adapt it yourself :-) To check that the modifications of the PATH variable worked, execute $ echo $PATH It prints all folders that are scanned for executable files. The list should contain the bin folder in your HOME directory at the end. Download and install subpatch The last step is to download the subpatch script and copy it into the bin folder. First go to the releases page and find the latest release. There are two options: manual download or using the command line: Manual download Now click on the link for standalone python script and download the script with your browser. After you downloaded the standalone script into your download directory, you must move it to the bin directory. For example: $ mv subpatch ~/bin/ The executable bit is not set for downloaded files. You must manually set it with the command $ chmod +x ~/bin/subpatch Otherwise the shell cannot execute the script. Using the command line Apart from the manual download, you can use command line tools. To download the script and set the executable bit, just execute: $ wget https://github.com/lengfeld/subpatch/releases/download/v0.1a2/subpatch -O ~/bin/subpatch $ chmod +x ~/bin/subpatch The above command is just an example. For other versions of subpatch, the version number in the URL looks different. Test subpatch After download and installation you should test the subpatch command line tool. To test that it works, you can execute the command $ subpatch --version It should print the version number of subpatch that is currently installed. Congratulations , now you successfully installed subpatch. A final note: To get further infos and the help text, execute $ subpatch --help","title":"Installation"},{"location":"tut/installation/#installation","text":"This tutorial explains who to install subpatch on your computer. Currently there are two ways to install subpatch: With pipx into your HOME directory As a standalone script into the PATH NOTE : subpatch is currently in a very very early stage. Do not use it in production environments!","title":"Installation"},{"location":"tut/installation/#prerequisites","text":"To follow this tutorial you need a PC or notebook with a Linux Operating System installed. This tutorial will assume Ubuntu , but any current distribution should work. Also MacOS may work out of the box, but it's not tested for now.","title":"Prerequisites"},{"location":"tut/installation/#with-pipx-into-your-home-directory","text":"The subpatch project is released on PyPI , the \"Python Package Index\". The PyPI's subpatch site contains the project specific informations.","title":"With pipx into your HOME directory"},{"location":"tut/installation/#install-pipx","text":"To install subpatch, you can use pipx . pipx is a tool to manage python virtual environments in your HOME directory. To install pipx on Ubuntu, execute $ sudo apt install pipx NOTE : For other distributions use the distro specific package manager. To check if pipx works, you can execute the list command. An example: $ pipx list nothing has been installed with pipx \ud83d\ude34","title":"Install pipx"},{"location":"tut/installation/#install-subpatch-with-pipx","text":"If everything is fine, you can install the latest version of subpatch with the command $ pipx install subpatch The output of the command should look like installed package subpatch 0.1a2, installed using Python 3.10.12 These apps are now globally available - subpatch done! \u2728 \ud83c\udf1f \u2728 If some of the numbers are different, that's o.k. To test that subpatch works, you can execute the command $ subpatch --version It should print the version number of subpatch that is currently installed. Congratulations , now you successfully installed subpatch. A final note: To get further infos and the help text, execute $ subpatch --help","title":"Install subpatch with pipx"},{"location":"tut/installation/#as-a-standalone-script-into-the-path","text":"You can also install subpatch as a standalone python script into your PATH.","title":"As a standalone script into the PATH"},{"location":"tut/installation/#create-a-bin-folder","text":"First make sure that you have a directory that is listed in your PATH. If you have another folder in the PATH for other scripts already, you can skip this step. I used a bin directory in the HOME folder for that. To create it, execute $ mkdir ~/bin Then this folder must be added to the environment variable PATH. This can be done with $ echo 'export PATH=$PATH:$HOME/bin' >> ~/.bashrc It adds a line at the end of the ~./bashrc file. The change will only be active in new shells that are spawned now. So start a new shell with $ bash NOTE : This tutorial assumes that you are using bash. If you use another shell, like zsh or fish, you mostly already know everything in the tutorial and can adapt it yourself :-) To check that the modifications of the PATH variable worked, execute $ echo $PATH It prints all folders that are scanned for executable files. The list should contain the bin folder in your HOME directory at the end.","title":"Create a bin folder"},{"location":"tut/installation/#download-and-install-subpatch","text":"The last step is to download the subpatch script and copy it into the bin folder. First go to the releases page and find the latest release. There are two options: manual download or using the command line:","title":"Download and install subpatch"},{"location":"tut/installation/#manual-download","text":"Now click on the link for standalone python script and download the script with your browser. After you downloaded the standalone script into your download directory, you must move it to the bin directory. For example: $ mv subpatch ~/bin/ The executable bit is not set for downloaded files. You must manually set it with the command $ chmod +x ~/bin/subpatch Otherwise the shell cannot execute the script.","title":"Manual download"},{"location":"tut/installation/#using-the-command-line","text":"Apart from the manual download, you can use command line tools. To download the script and set the executable bit, just execute: $ wget https://github.com/lengfeld/subpatch/releases/download/v0.1a2/subpatch -O ~/bin/subpatch $ chmod +x ~/bin/subpatch The above command is just an example. For other versions of subpatch, the version number in the URL looks different.","title":"Using the command line"},{"location":"tut/installation/#test-subpatch","text":"After download and installation you should test the subpatch command line tool. To test that it works, you can execute the command $ subpatch --version It should print the version number of subpatch that is currently installed. Congratulations , now you successfully installed subpatch. A final note: To get further infos and the help text, execute $ subpatch --help","title":"Test subpatch"}]}