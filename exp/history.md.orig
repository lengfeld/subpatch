# Pre-subpatch history

subpatch is not my first attempt to solve the multi repository problem. There
is a long history before I started the subpatch project. This page should tell
<<<<<<< HEAD
the history and what learnings I made along the way. These learnings lead to
[the design and the requirements](design.md) of subpatch.

lt;dr: The summary of all learnings is

* (**L1**) The solution to the multi repository problem is inside of git
  (or generally inside any version control system).
* (**L2**) Good documentation is very very important.
* (**L3**) Good documentation with good tooling is the key.
* (**L4**) Use the right design to minimize the inherent complexity to avoid
   accidental complexity.
* (**L5**) The build process must not span multiple of your own repositories.
* (**L6**) The only sane way to maintain a downstream fork is a linear patch
  stack (series of patches).
* (**L7**) Good development practices, like atomic commits, must still be
  possible with the multi repository management tool. Even across the used
  subprojects.
=======
my path in this problem space and what learnings I made along the way. These
learnings lead to [the design and the requirements](design.md) of subpatch.

lt;dr: The summary of all learnings is 

* (**L1**): The solution to the multi repository problem is **inside** of git
  (or general inside any version control system).
>>>>>>> e8ddbf5 (add work in progres stuff)


## Personal history

<<<<<<< HEAD
While writing these lines it's the year 2024. I started to use Linux in my
youth and also started to code at the same time. That is nearly 20 years in the
past now. So I may claim that I've been doing software development for 15+
years.

In university, around 2011, I started to write software as a research
assistant. Since 2014 (ten years) I've been doing embedded software development
as my main job and can call myself a professional software developer. In all these
years I have already seen a lot of programming languages, projects and problems.
=======
While writing these lines it's the year 2024. I'm using Linux since nearly 20
years now and also started to code at the same time. So I claim that I'm doing
software development since 15+ years. I'm grew up in the time of the web 2.0
and the LAMP stack (Linux, Apache, MySQL and PHP). I still maintain some
Wordpress websites and can write SQL queries ;-)

In university I started to write software as a research assistant. Since 2014
(ten years) I'm doing embedded software development as my main job and can name
me a professional software developer. I already seen a lot of programming
languages, projects and problems.
>>>>>>> e8ddbf5 (add work in progres stuff)


## Multi repository problem (2015)

<<<<<<< HEAD
In 2015 at my first embedded software development job I encountered the multi
repository problem. The company was on the way to migrate the embedded build
system for their Linux distribution and firmware images to Yocto.

Back then I started to learn and use the [repo tool by
Google](https://gerrit.googlesource.com/git-repo) to manage projects with
multiple repositories.  While doing the first releases of the Linux firmware, I
noticed the weaknesses of using repo. Everything that is easy with a single
repository like
=======
In 2015 at my first embedded software development I first encountered the multi
repository problem. The company was on the way to migrate the embedded build
system for their Linux distribution and firmware images to Yocto.

That's the first time I encountered the multi repository problem. Back then I
started to learn and use the repo tool by Google to manage project with
multiple repositories.

While doing the first releases of the Linux firmware, I noticed the weaknesses
of using repo. Everything that is easy with a single repository like
>>>>>>> e8ddbf5 (add work in progres stuff)

* checking out branches of a coworker,
* switching between different development branches (stable vs main),
* bisecting errors and
* making a release and tagging

<<<<<<< HEAD
becomes a major hassle with multiple repositories and the repo tool. And it's
very error prone. At that time I started a new hobby project called *rap*.


## The solution is inside a git repo (2015)

So I'm working on a better version of the repo, called *rap*, for three months.
It should be repo by Google done right. I wrote it in python and at the end it
consists of
=======
becomes a major hassle with multiple repositories and the repo tool. And it
it's very error prone.

At that time I started a new hobby project called `rap`. It should be like the
repo, tool, but doing right.


## The solution is inside a git repo

I'm working on a better version of the repo, internally called `rap`, for three
months. It should be repo by Google done right. I wrote it in python and at the
end it consists of
>>>>>>> e8ddbf5 (add work in progres stuff)

* 2889 lines of code for the program and
*  985 lines of tests.

It should support features, like easy checkout of multiple repos, bisecting
across multiple repos and git bundles across multi repos.

After the three months I noticed that I was building a version control system
<<<<<<< HEAD
for git repositories. And git is itself a version control system. That is
duplicate and useless work. This brought me to the first learning:

(**L1**) The solution to the multi repository problem is **inside** of git (or
generally inside any version control system). The solution is **not** writing a
new version control system to manage version control systems.

So I abandoned the rap project and looked at existing solutions that allow me
to manage multiple repositories inside a git repo. Most people know *git
submodules*, but there is also *git subtree*.


## Documentation, documentation and documentation (2015)

I already knew [git submodules](https://git-scm.com/book/en/v2/Git-Tools-Submodules)
and also knew that has its own set of usability challenges. So I looked at
[git subtree](https://git.kernel.org/cgit/git/git.git/tree/contrib/subtree/git-subtree.txt)
and its
[subtree merge strategy](https://mirrors.edge.kernel.org/pub/software/scm/git/docs/howto/using-merge-subtree.html).
Maybe it's a viable solution.

After trying it out I noticed that the documentation is lacking. I started to
write additional documentation for it and called the project *Handbook of
Applied git subtree merge*.

The problem is explaining the problem to developers and explaining how the
tool works to solve the management problem. This can be summarized up in the
learning:

(**L2**) Good documentation is very very important.

Quickly after that I also noticed that the tooling of git subtree is
inadequate. Only additional documentation will not fix usability issues.  The
third learning is:

(**L3**) Good documentation with good tooling is the key.
=======
for git. And git is itself a version control system. That is madness and
useless work. This brought me to the first learning:

(**L1**) The solution to the multi repository problem is **inside** of git (or
general inside any version control system). The solution is **not** writing a
new version control system to manage version control systems.

So I abdonded the `rap` project and look at existing solutions that allow to
manage multiple repositories inside a git repo. Most people know `git submodules`, but
there is also `git subtree`.


## Better Complexity and Documentation

I already knew `git submodules` and also knew that it has has own set of
usability challenges. So I looked at `git subtree` and it's subtree merge
strategy. Maybe it's a viable solution.

After trying it out I noticed that the documentation is lacking. I started to
write additional documentation for it and called the project "Handbook of
Applied git subtree merge".

(**L2**) Problem is complex, documentation is needed and usability
TODO That is the wrong learning. It must be something like git submodules does not fly

Quickly after that I also noticed that the tooling of `git subtree` is
inadequate. Only additional documentation will not fix usability issues.

(**L3*) Documentation and tooling is the key
TODO That is the wrong learning. It must be something like git submodules does not fly
>>>>>>> e8ddbf5 (add work in progres stuff)


## Better Tooling (2016)

In 2016 I started to work on better tooling for git subtree. I called the
<<<<<<< HEAD
project *git-subtreemerge*. It should be git subtree done right. A better
=======
project `git-subtreemerge`. It should be `git subtree` done right. A better
>>>>>>> e8ddbf5 (add work in progres stuff)
tool to perform and help the user to use the subtree merge strategy of git.

I worked on this project from June 2016 to May 2017 (roughly eight months) in
my spare time. At the end the project consist of

* 5027 lines of python code for the program and
* 9544 lines of python code lines are tests.

So 65% percent of all the code are tests.

<<<<<<< HEAD
At this stage the basic features were working in the tool and I wanted to
release it as a prototype. So I started to work on the documentation that
explains how the tool works and the theory behind it.

I quickly noticed that this would not fly. It's not about the accidental
complexity of the git subtree merge strategy or the tool. It's about the
essential or inherent complexity of it. The core problem is that the merge
strategy is mixing commits of the subproject into the history (the commit
graph) of the superproject. If you have multiple subprojects, then you
also have multiple different types of subproject commits in the history
of the superproject.

Combine this with changes to the subproject in the superproject and combine
this with merges (different development branches) in the superproject, you get
a complexity explosion of everything that can happen and must be explained.
In fact there are mathematical underlying properties, embeddings and
commutative operations, for this. So in general it's sound.  But this setup is
not explainable to even experienced git users.

At this point I abandoned the project. My main learning was

(**L4**) Use the right design to minimize the inherent complexity to avoid
accidental complexity.

To phrase it for the git subtree merge strategy. It has a huge inherent
complexity, which is way too big for the essential complexity of the multi
repository management problem.
=======
Conceptionally the idea of subtree merge is valid. It's theoretical sound and
does work, there is a mathematical property behind it.

When I was nearly at the point of releasing a first preview of the tool
`git-subtreemerge`, I started to write the documentation. Then I noticed how
hard and complex the subtree merge strategy is. It cannot be explained to even
experienced git users.

The main problem is when doing a subtree merge, the history of the superproject
and the subproject are merged together into a single commit graph (=a single
history). Your project will contain two different kind of commits: commits of
the subproject and commits of the subproject. If the project has multiple
subprojects, you have multiple different types of subproject commits in the
history. Just from looking an individual commit, e.g. when doing a `git log`,
you cannot distinguish the different types of commits. You must always look at
the context.

This is really unnecessary complexity. That situation is a bit like when a
language introduces async functions in the language. E.g. see the essay
[What Color is Your Function?](https://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/)
And in the subtree merge case there are not just two different colors for two
different types of functions, but multiple different colors for multiple
different kinds of subprojects.

(**L3**) git subtree merge strategy does not fly. Mixing commits of the
superproject and the subproject introduces to much complexity.

(**L3.1*) 
>>>>>>> e8ddbf5 (add work in progres stuff)


## Gerrit and repo (2018)

In 2018 I had the chance to work on a project that uses the [Gerrit Code Review
System](https://www.gerritcodereview.com/) together with the repo tool. I did
expect the same problems as in the year 2016, but gave the combination of
gerrit plus repo another try.

<<<<<<< HEAD
Summary: It's still madness. Even simple things like checking out the
=======
Summary: It's still a madness. Even simple things like checking out the
>>>>>>> e8ddbf5 (add work in progres stuff)
branches of a coworker is non-trivial. It's not supported by the repo tool. We
started to implement our own tool called
[repoload](https://github.com/lengfeld/repoload) for that.

<<<<<<< HEAD
At least Gerrit supports submitting/accepting cross atomic commits.  That's a
feature you need when you start to distribute your project across multiple
git repos. The documentation
[Submitting Changes Across Repositories by using Topics](https://gerrit-review.googlesource.com/Documentation/cross-repository-changes.html).

So Gerrit has the cross repo atomic commit feature. Sadly our continuous
integration system (CI), Jenkins in this case, did not.  Our project rolled out its
own implementation based on the `Change-Id` and `Depends-On` fields in the
commit messages. Writing in a combination of bash and groovy. Also madness.

There were a couple of other learnings from this project which I can summarize
up as:

(**L5**) The build process must not span multiple of your own repositories.

You can also phrase it differently. When you or your CI system must checkout
multiple of your own git repos for building the project, you are doing it
wrong.


## git add and linear patch stacks (2018+)

In the same project we used a different solution (not repo or git submodules)
for a small component.  We integrated a C++ dependency into the git repository
with `git add`. We just added the source files in a single commit into the
project. We even applied local patches to the project as normal git commits on
top of it.

When upgrading the dependency we removed the original files, added the new
source files and reapplied the patches with `git cherry-pick`. That process
worked nicely. The learning is:

(**L6**) The only sane way to maintain a downstream fork is a linear patch
stack (series of patches).

And that is actually a very old thing. Linux distributions, like the big ones
for the desktop but also for embedded devices, maintain a linear patch stack
for their packages (=source dependencies). It's a process that has been done
for decades now.
=======
Gerrit support submitting/accepting cross atomic commits at the same time. See
the documentation
[Submitting Changes Across Repositories by using Topics](https://gerrit-review.googlesource.com/Documentation/cross-repository-changes.html).
But the CI like Jenkins does not. So the project rolled out it's own
implementation based on the `Change-Id` and `Depends-On` fields in the 
commit messages. 

TODO learning same madness??

## `git add` to the resuce

But an idea was born or actually reborn in this project. We integrated a C++
dependency into a git repository with `git add`. We just added the source files
in a single commit into the project. And we even applied local patches to the
project as normal git commits.

When upgrading the dependency we removed the original files, added the new
source files and reapplied the patches. That process worked nicely.

(**L4**): `git add` with extra meta data is the solution.
>>>>>>> e8ddbf5 (add work in progres stuff)


## Conclusion

<<<<<<< HEAD
That is my history and how I came up with the design of subpatch. Hopefully it
shows that the requirements and design decision are not an ad-hoc idea, but
instead based on a long period of experience and tackling the multi repository
problem from different angles.

One last learning that also feeds into subpatch is

(**L7**) Good development practices, like atomic commits, must still be
possible with the multi repository management tool. Even across the used
subprojects.
=======
The main task




## TODO remove


Compared to other embedded build systems Yocto (and Open
Embedded) is a diverse ecosystem without a single central repository. It's
based on the concept of layers that are separate git repositories that are also
maintained and hosted by different parties around the internet.

When building an embedded firmware with Yocto, you must clone several git
repositories onto your build machine. Mostly you clone the poky (containing the
core, like bitbake, the toolchain and the most important recipes) and others
layers to support your embedded hardware platform (custom bootloader and Linux
kernel) and integrate additional software.

The main point is that your project to build a single firmware image for your
embedded board consists of multi git repositories. That's the *multi repository
problem*. A single project consists of multiple repositories and there exist
interdependencies between the repositories.

So 2015
>>>>>>> e8ddbf5 (add work in progres stuff)
