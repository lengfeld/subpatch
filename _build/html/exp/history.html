

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Pre-subpatch history &mdash; subpatch  documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=7ab3649f" />

  
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=5929fcd5"></script>
      <script src="../_static/doctools.js?v=9a2dae69"></script>
      <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            subpatch
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Explanation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="intro.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="design.html">subpatch design</a></li>
<li class="toctree-l1"><a class="reference internal" href="comparison.html">Comparison to other tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="comparison.html#other-multi-repository-management-tools">Other multi repository management tools</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Tutorials</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../tut/installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tut/basic-usage.html">Basic usage</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../ref/glossary.html">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ref/releases.html">Releases</a></li>
<li class="toctree-l1"><a class="reference internal" href="../imprint.html">Imprint</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">subpatch</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Pre-subpatch history</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/exp/history.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="pre-subpatch-history">
<h1>Pre-subpatch history<a class="headerlink" href="#pre-subpatch-history" title="Link to this heading"></a></h1>
<p>subpatch is not my first attempt to solve the multi repository problem. There
is a long history before I started the subpatch project. This page should tell
the history and what learnings I made along the way. These learnings lead to
<a class="reference internal" href="design.html"><span class="std std-doc">the design and the requirements</span></a> of subpatch.</p>
<p>lt;dr: The summary of all learnings is</p>
<ul class="simple">
<li><p>(<strong>L1</strong>) The solution to the multi repository problem is inside of git
(or generally inside any version control system).</p></li>
<li><p>(<strong>L2</strong>) Good documentation is very very important.</p></li>
<li><p>(<strong>L3</strong>) Good documentation with good tooling is the key.</p></li>
<li><p>(<strong>L4</strong>) Use the right design to minimize the inherent complexity to avoid
accidental complexity.</p></li>
<li><p>(<strong>L5</strong>) The build process must not span multiple of your own repositories.</p></li>
<li><p>(<strong>L6</strong>) The only sane way to maintain a downstream fork is a linear patch
stack (=series of patches).</p></li>
<li><p>(<strong>L7</strong>) Good development practices, like atomic commits, must still be
possible with the multi repository management tool. Even across the used
subprojects.</p></li>
</ul>
<section id="personal-history">
<h2>Personal history<a class="headerlink" href="#personal-history" title="Link to this heading"></a></h2>
<p>While writing these lines it’s the year 2024. I started to use Linux in my
youth and also started to code at the same time. That is nearly 20 years in the
past now. So I may claim that I’ve been doing software development for 15+
years.</p>
<p>In university, around 2011, I started to write software as a research
assistant. Since 2014 (ten years) I’ve been doing embedded software development
as my main job and can call myself a professional software developer. In all these
years I have already seen a lot of programming languages, projects and problems.</p>
</section>
<section id="multi-repository-problem-2015">
<h2>Multi repository problem (2015)<a class="headerlink" href="#multi-repository-problem-2015" title="Link to this heading"></a></h2>
<p>In 2015 at my first embedded software development job I encountered the multi
repository problem. The company was on the way to migrate the embedded build
system for their Linux distribution and firmware images to Yocto.</p>
<p>Back then I started to learn and use the <a class="reference external" href="https://gerrit.googlesource.com/git-repo">repo tool by
Google</a> to manage projects with
multiple repositories.  While doing the first releases of the Linux firmware, I
noticed the weaknesses of using repo. Everything that is easy with a single
repository like</p>
<ul class="simple">
<li><p>checking out branches of a coworker,</p></li>
<li><p>switching between different development branches (stable vs main),</p></li>
<li><p>bisecting errors and</p></li>
<li><p>making a release and tagging</p></li>
</ul>
<p>becomes a major hassle with multiple repositories and the repo tool. And it’s
very error prone. At that time I started a new hobby project called <em>rap</em>.</p>
</section>
<section id="the-solution-is-inside-a-git-repo-2015">
<h2>The solution is inside a git repo (2015)<a class="headerlink" href="#the-solution-is-inside-a-git-repo-2015" title="Link to this heading"></a></h2>
<p>So I’m working on a better version of the repo, called <em>rap</em>, for three months.
It should be repo by Google done right. I wrote it in python and at the end it
consists of</p>
<ul class="simple">
<li><p>2889 lines of code for the program and</p></li>
<li><p>985 lines of tests.</p></li>
</ul>
<p>It should support features, like easy checkout of multiple repos, bisecting
across multiple repos and git bundles across multi repos.</p>
<p>After the three months I noticed that I was building a version control system
for git repositories. And git is itself a version control system. That is
duplicate and useless work. This brought me to the first learning:</p>
<p>(<strong>L1</strong>) The solution to the multi repository problem is <strong>inside</strong> of git (or
generally inside any version control system). The solution is <strong>not</strong> writing a
new version control system to manage version control systems.</p>
<p>So I abandoned the rap project and looked at existing solutions that allow me
to manage multiple repositories inside a git repo. Most people know <em>git
submodules</em>, but there is also <em>git subtree</em>.</p>
</section>
<section id="documentation-documentation-and-documentation-2015">
<h2>Documentation, documentation and documentation (2015)<a class="headerlink" href="#documentation-documentation-and-documentation-2015" title="Link to this heading"></a></h2>
<p>I already knew <a class="reference external" href="https://git-scm.com/book/en/v2/Git-Tools-Submodules">git submodules</a>
and also knew that has its own set of usability challenges. So I looked at
<a class="reference external" href="https://git.kernel.org/cgit/git/git.git/tree/contrib/subtree/git-subtree.txt">git subtree</a>
and its
<a class="reference external" href="https://mirrors.edge.kernel.org/pub/software/scm/git/docs/howto/using-merge-subtree.html">subtree merge strategy</a>.
Maybe it’s a viable solution.</p>
<p>After trying it out I noticed that the documentation is lacking. I started to
write additional documentation for it and called the project <em>Handbook of
Applied git subtree merge</em>.</p>
<p>The problem is explaining the problem to developers and explaining how the
tool works to solve the management problem. This can be summarized up in the
learning:</p>
<p>(<strong>L2</strong>) Good documentation is very very important.</p>
<p>Quickly after that I also noticed that the tooling of git subtree is
inadequate. Only additional documentation will not fix usability issues.  The
third learning is:</p>
<p>(<strong>L3</strong>) Good documentation with good tooling is the key.</p>
</section>
<section id="better-tooling-2016">
<h2>Better Tooling (2016)<a class="headerlink" href="#better-tooling-2016" title="Link to this heading"></a></h2>
<p>In 2016 I started to work on better tooling for git subtree. I called the
project <em>git-subtreemerge</em>. It should be git subtree done right. A better
tool to perform and help the user to use the subtree merge strategy of git.</p>
<p>I worked on this project from June 2016 to May 2017 (roughly eight months) in
my spare time. At the end the project consist of</p>
<ul class="simple">
<li><p>5027 lines of python code for the program and</p></li>
<li><p>9544 lines of python code lines are tests.</p></li>
</ul>
<p>So 65% percent of all the code are tests.</p>
<p>At this stage the basic features were working in the tool and I wanted to
release it as a prototype. So I started to work on the documentation that
explains how the tool works and the theory behind it.</p>
<p>I quickly noticed that this would not fly. It’s not about the accidental
complexity of the git subtree merge strategy or the tool. It’s about the
essential or inherent complexity of it. The core problem is that the merge
strategy is mixing commits of the subproject into the history (the commit
graph) of the superproject. If you have multiple subprojects, then you
also have multiple different types of subproject commits in the history
of the superproject.</p>
<p>Combine this with changes to the subproject in the superproject and combine
this with merges (different development branches) in the superproject, you get
a complexity explosion of everything that can happen and must be explained.
In fact there are mathematical underlying properties, embeddings and
commutative operations, for this. So in general it’s sound.  But this setup is
not explainable to even experienced git users.</p>
<p>At this point I abandoned the project. My main learning was</p>
<p>(<strong>L4</strong>) Use the right design to minimize the inherent complexity to avoid
accidental complexity.</p>
<p>To phrase it for the git subtree merge strategy. It has a huge inherent
complexity, which is way too big for the essential complexity of the multi
repository management problem.</p>
</section>
<section id="gerrit-and-repo-2018">
<h2>Gerrit and repo (2018)<a class="headerlink" href="#gerrit-and-repo-2018" title="Link to this heading"></a></h2>
<p>In 2018 I had the chance to work on a project that uses the <a class="reference external" href="https://www.gerritcodereview.com/">Gerrit Code Review
System</a> together with the repo tool. I did
expect the same problems as in the year 2016, but gave the combination of
gerrit plus repo another try.</p>
<p>Summary: It’s still madness. Even simple things like checking out the
branches of a coworker is non-trivial. It’s not supported by the repo tool. We
started to implement our own tool called
<a class="reference external" href="https://github.com/lengfeld/repoload">repoload</a> for that.</p>
<p>At least Gerrit supports submitting/accepting cross atomic commits.  That’s a
feature you need when you start to distribute your project across multiple
git repos. The documentation
<a class="reference external" href="https://gerrit-review.googlesource.com/Documentation/cross-repository-changes.html">Submitting Changes Across Repositories by using Topics</a>.</p>
<p>So Gerrit has the cross repo atomic commit feature. Sadly our continuous
integration system (CI), Jenkins in this case, did not.  Our project rolled out its
own implementation based on the <code class="docutils literal notranslate"><span class="pre">Change-Id</span></code> and <code class="docutils literal notranslate"><span class="pre">Depends-On</span></code> fields in the
commit messages. Writing in a combination of bash and groovy. Also madness.</p>
<p>There were a couple of other learnings from this project which I can summarize
up as:</p>
<p>(<strong>L5</strong>) The build process must not span multiple of your own repositories.</p>
<p>You can also phrase it differently. When you or your CI system must checkout
multiple of your own git repos for building the project, you are doing it
wrong.</p>
</section>
<section id="git-add-and-linear-patch-stacks-2018">
<h2>git add and linear patch stacks (2018+)<a class="headerlink" href="#git-add-and-linear-patch-stacks-2018" title="Link to this heading"></a></h2>
<p>In the same project we used a different solution (not repo or git submodules)
for a small component.  We integrated a C++ dependency into the git repository
with <code class="docutils literal notranslate"><span class="pre">git</span> <span class="pre">add</span></code>. We just added the source files in a single commit into the
project. We even applied local patches to the project as normal git commits on
top of it.</p>
<p>When upgrading the dependency we removed the original files, added the new
source files and reapplied the patches with <code class="docutils literal notranslate"><span class="pre">git</span> <span class="pre">cherry-pick</span></code>. That process
worked nicely. The learning is:</p>
<p>(<strong>L6</strong>) The only sane way to maintain a downstream fork is a linear patch
stack (=series of patches).</p>
<p>And that is actually a very old thing. Linux distributions, like the big ones
for the desktop but also for embedded devices, maintain a linear patch stack
for their packages (=source dependencies). It’s a process that has been done
for decades now.</p>
</section>
<section id="conclusion">
<h2>Conclusion<a class="headerlink" href="#conclusion" title="Link to this heading"></a></h2>
<p>That is my history and how I came up with the design of subpatch. Hopefully it
shows that the requirements and design decision are not an ad-hoc idea, but
instead based on a long period of experience and tackling the multi repository
problem from different angles.</p>
<p>One last learning that also feeds into subpatch is</p>
<p>(<strong>L7</strong>) Good development practices, like atomic commits, must still be
possible with the multi repository management tool. Even across the used
subprojects.</p>
</section>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Stefan Lengfeld.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>